------------------------------------------------------------------------------------------------------
--STS001: Number of requests for support receieved from NEW CLIENTS, broken down by sequels to Request
------------------------------------------------------------------------------------------------------


/*This version of the STS001 code applies the logic of searching the chronology for all Request records in the 
first instance and only after this defaulting back to the Event Outcome where appropriate.

The ST-MAX cohort for STS002a is also created and staged into a table as part of this code process (see Row 749 where 
Table Name needs defining)
*/





-----------------------------------------------------
/*CREATE REFERENCE MAPPING TABLE FOR EVENT OUTCOMES*/
-----------------------------------------------------
--NOTE: Check periodically to ensure the Defined List in CLD spec has not changed!
drop table if exists #REF_SEQUEL_MAPPING
create table #REF_SEQUEL_MAPPING
(Event_Outcome varchar(200)
,Mapping_Code int
,Mapping_Description varchar(50))

insert into #REF_SEQUEL_MAPPING
(Event_Outcome 
,Mapping_Code
,Mapping_Description)
values
('Progress to Reablement/ST-Max', 2, 'Unable_To_Classify')
,('Progress to Assessment', 2, 'Unable_To_Classify')
,('Admitted to hospital', 2, 'Unable_To_Classify')
,('Progress to Re-assessment / Unplanned Review', 2, 'Unable_To_Classify')
,('Progress to Support Planning / Services', 2, 'Unable_To_Classify')
,('Progress to End of Life Care', 1, 'End of Life')
,('No change in package', 2, 'Unable_To_Classify')
,('Service ended as planned', 2, 'Unable_To_Classify')
,('NFA - Moved to another LA', 1, 'No Services Provided - other reason')
,('NFA - 100% NHS funded care', 1, '100% NHS Funded Care')
,('NFA - Self-funded client (Inc. 12wk disregard)', 1, 'No Services Provided - other reason')
,('NFA - Support declined', 1, 'No Services Provided - other reason')
,('NFA - Information & Advice / Signposting only', 1, 'Universal Services/ Signposted to other services')
,('NFA - Deceased', 1, 'No Services Provided - Deceased')
,('NFA - No services offered: Other reason', 1, 'No Services Provided - other reason')
,('NFA - Support ended: Other reason', 1, 'No Services Provided - other reason')
,('Progress to financial assessment', 2, 'Unable_To_Classify')
,('Provision of service', 2, 'Unable_To_Classify')
,('NFA- Other', 1, 'No Services Provided - other reason')
;



---------------------------------------------------------------------------------------------------
/*CREATE REFERENCE TABLE #REF_SERVICE_TYPE TO CATEGORISE AND RANK ITEMS FOR STS001*/
---------------------------------------------------------------------------------------------------
--NOTE: Check periodically to ensure the Defined List in CLD spec has not changed!
drop table if exists #REF_Service_Type	
create table #REF_Service_Type
(Service_Type varchar(200)
,Sort_Order int
,Hierarchy int)

insert into #REF_Service_Type
(Service_Type
,Sort_Order
,Hierarchy
)
values
('Short Term Support: ST-Max', 1, 1)
,('Long Term Support: Nursing Care', 2, 2)
,('Long Term Support: Residential Care',  3, 3)
,('Long Term Support: Community',  4, 4)
,('Long Term Support: Prison', 5, 5)
,('Short Term Support: Ongoing Low Level', 6, 6)
,('Short Term Support: Other Short Term', 7, 7)
;



------------------------------------------------------------------------------------------------------------------------
/*CREATE REFERENCE TABLE #REF_EVENT_OUTCOME_HIERARCHY TO DE-DUPLICATE WHERE MULTIPLE CONFLICTING EVENT OUTCOMES APPEAR*/
------------------------------------------------------------------------------------------------------------------------
--NOTE: Check periodically to ensure the Defined List in CLD spec has not changed!
drop table if exists #REF_Event_Outcome_Hierarchy
create table #REF_Event_Outcome_Hierarchy
(Event_Outcome varchar(200)
,Event_Outcome_Hierarchy int)

insert into #REF_Event_Outcome_Hierarchy
(Event_Outcome
,Event_Outcome_Hierarchy
)
values
('Progress to Reablement/ST-Max', 1)
,('Progress to Assessment', 2)
,('Admitted to Hospital', 3)
,('Progress to Re-assessment / Unplanned Review', 4)
,('Progress to Support Planning / Services', 5)
,('Progress to End of Life Care', 6)
,('No change in package', 7)
,('Service ended as planned', 8)
,('Progress to financial assessment', 9)
,('Provision of service', 10)
,('NFA - Deceased', 11)
,('NFA - Moved to another LA', 12)
,('NFA - 100% NHS-funded care', 13)
,('NFA - Information & Advice / Signposting only', 14)
,('NFA - Self-funded client (inc. 12wk disregard)', 15)
,('NFA - Support declined', 16)
,('NFA - Support ended â€“ other reason', 17)
,('NFA - No services offered - other reason', 18)
,('NFA- Other', 19)
;





---------------------------------------------------------------------------
/*FILTER DATA APPROPRIATELY FOR INDIVIDUALS AND SELECT PERIOD OF INTEREST*/
---------------------------------------------------------------------------
DECLARE
  @StartDate DATE,
  @EndDate   DATE

SET @StartDate = '2023-04-01'  -- Complete as required
SET @EndDate = '2023-12-31'    -- Complete as required


--Pull out all Event Types here as, although STS001 relates to Requests, the sequel to these Requests that we are trying to determine may contain any
--Event Types as part of the onward cluster of activity leading to a Service
drop table IF EXISTS #ALL_EVENTS_BUILD
select *
, CAST((concat(Der_Birth_Year, '-', Der_Birth_Month, '-', '01')) as DATE) as [Der_DOB] -- Derived using 1st month as an arbitrary date
, FLOOR((DATEDIFF (DAY, (CAST(concat(Der_Birth_Year, '-', Der_Birth_Month, '-', '01') as DATE)), @EndDate))/365.25) as [Der_Age_EndDate]-- Derived age as at period end, using Der_DOB
into #ALL_EVENTS_BUILD
from [DHSC_ASC].[CLD_R1_Raw]
where [Event_Type] in ('Service', 'Request', 'Review', 'Assessment')
and Event_Start_Date <= @EndDate
and (Der_Birth_Month is not NULL and Der_Birth_Year is not NULL)-- NULLs break the CAST code above for DER_DOB, must be removed as not able to be age banded anyway
and (Date_of_Death >= @StartDate OR Date_of_Death is NULL) -- This filter removes Clients who have a recorded date of death at this outset stage
and Client_Type = 'Service User'
;


-----------------------------------------
/*CREATE AMALGAMATED NHS/LA IDENTIFIER*/
-----------------------------------------

--initially, find all individuals with an NHS Number and stage into a temporary table                              
drop table if exists #uniquenhs
SELECT DISTINCT Der_Unique_Record_ID, Der_NHS_Number_Traced_Pseudo, Der_LA_Person_Unique_Identifier_Pseudo, 'NHS' as [Source]                                                                                                                                                     
INTO #uniquenhs                                                                                                                                                           
FROM #ALL_EVENTS_BUILD                                                                                                                                           
where Der_NHS_Number_Traced_Pseudo is not NULL                                                                                          
;


--where the NHS Number is missing, pull through all individuals LA Unique ID
--except in those cases where the LA Unique ID is already present and associated with an individual in #uniquenhs
drop table if exists #missingnhs
SELECT distinct a.Der_Unique_Record_ID, a.Der_NHS_Number_Traced_Pseudo, a.Der_LA_Person_Unique_Identifier_Pseudo, 'LA' as [Source]                                                                             
INTO #missingnhs                                                                                                                                                           
FROM #ALL_EVENTS_BUILD a                                                                                                                                                
left join #uniquenhs b on a.Der_LA_Person_Unique_Identifier_Pseudo = b.Der_LA_Person_Unique_Identifier_Pseudo                                                                                                          
where a.Der_NHS_Number_Traced_Pseudo is NULL                                                                                              
and b.Der_LA_Person_Unique_Identifier_Pseudo is NULL                                                                                     
;


--Stack the NHS IDs and the LA IDs from the two temp tables underneath each other in a final table, as an amalgamated 'ID' field
drop table if exists #FINAL
select distinct Der_Unique_Record_ID, Der_NHS_Number_Traced_Pseudo as [ID], [Source]                                     
into #FINAL                                                                                                                                                                     
from #uniquenhs                                                                                                                                                           
UNION                                                                                                                                                               
select distinct Der_Unique_Record_ID, Der_LA_Person_Unique_Identifier_Pseudo as [ID], [Source]                        
from #missingnhs
;


--Add a column to Raw table with the new ID field
alter table #ALL_EVENTS_BUILD add [ID] nvarchar (200)
GO
;
update a
set a.[ID] = b.[ID]
from #ALL_EVENTS_BUILD a left join #FINAL b on a.Der_Unique_Record_ID = b.Der_Unique_Record_ID
;


--delete rows from table where [ID] is NULL
--These records can not be assigned to an individual with 100% accuracy and without the risk of double-counting 
--as the NHS ID is NULL and the LA ID is already present in the data associated to an NHS Number
delete from #ALL_EVENTS_BUILD
where [ID] is NULL
;


--------------------------------------------------------------
/*SELECT LATEST VERSION OF EACH EVENT USING BESPOKE EVENT ID*/
--------------------------------------------------------------
/*Use Concat of fields to create unique Event IDs for both Requests and Services in-line with how unique events are pin-pointed in 
the DHSC CLD Dashboard. CLD spec item Event Reference Number (ERN) has been used previously for this but local differences of how the 
ERN is applied in CLD have meant that it is not always robust enough to use a a unique event identifier.

Take the Latest Import Date where there are duplicates*/


--REQUEST EVENTS:
--Create Concatenation field
--NOTE: Event_End_Date is ommitted from CONCAT as we want to try to pin-point old events with NULL end dates as part of this process
drop table if exists #REQUESTS_WITH_CONC
select *
, concat(LA_CODE, [ID], CLIENT_TYPE, EVENT_START_DATE, Request_Route_of_Access) as [REQUEST_CONC]
into #REQUESTS_WITH_CONC
from #ALL_EVENTS_BUILD
where Event_Type = 'Request'
;



--Create table containing latest version of each submitted Request
drop table if exists #REQUESTS_LATEST
select *
into #REQUESTS_LATEST
from 
(
select *
, DENSE_RANK() OVER (PARTITION by [REQUEST_CONC] order by ImportDate desc) as RN
from #REQUESTS_WITH_CONC
where ImportDate <= '2024-02-01'  -- set submission date. Only submissions within the relevant CLD submission window can be considered (e.g. for Q3 snapshot of 31/12 the last day for LA submissions is 30/01
) a
where RN = 1
;


--SERVICE EVENTS:
--Create Concatenation field
--NOTE: Event_End_Date is ommitted from CONCAT as we want to try to pin-point old events with NULL end dates as part of this process
drop table if exists #SERVICES_WITH_CONC
select *
, concat(LA_CODE, [ID], CLIENT_TYPE, EVENT_START_DATE, Service_Type, Service_Component, Delivery_Mechanism) as [SERVICE_CONC]
into #SERVICES_WITH_CONC
from #ALL_EVENTS_Build
where Event_Type = 'Service'
;

--Create table containing latest version of each submitted Service
drop table if exists #SERVICES_LATEST
select *
into #SERVICES_LATEST
from 
(
select *
, DENSE_RANK() OVER (PARTITION by [SERVICE_CONC] order by ImportDate desc) as RN
from #SERVICES_WITH_CONC
where ImportDate <= '2024-02-01'  -- set submission date. Only submissions within the relevant CLD submission window can be considered (e.g. for Q3 snapshot of 31/12 the last day for LA submissions is 30/01
) a
where RN = 1
;



--UNION the latest REQUEST_LATEST to the SERVICES_LATEST table along with all the remaining rows (Review and Assessment rows)
--into a final ALL_EVENTS table
--We now have a table with all Reviews, Assessments, plus the LATEST SUBMITTED EDITION of each Request and Service row
drop table if exists #ALL_EVENTS
select *
into #ALL_EVENTS
from
(
select *
from #REQUESTS_LATEST
union
select *
from #SERVICES_LATEST
union
select *, '99' as [CONC], '99' as [RN] -- Populate with default/dummy information to allow the UNION of the Review and Assessment events from original ALL_EVENTS_BUILD (which doesn't contain these columns)
from #ALL_EVENTS_BUILD
where Event_Type not in ('Service', 'Request')
) a
;


--------------------------------------------------------------------------------------------


-------------------------
/*CREATE REQUESTS TABLE*/
-------------------------
/*Filter #ALL_EVENTS table for Requests, in order to start building the Request event clusters. It is accepted that one single Request for support can be recorded using multiple 
Request Event rows concurrently and/or consecutively within CLD. The code aims to cluster these chains together into one single Request wherever possible, with a Cluster Start Date
and a Cluster End Date (using set parameters agreed with LA working groups) to avoid over-counting Requests.

As part of this build, any NULL/Open Event End Dates will be assigned todays date, to allow the later clustering code to work correctly.

NOTE: We are still not removing any Events that have Ended BEFORE the period of interest Start Date yet, as although these Events in isolation are out of scope, they may form part of a 
chain/cluster of unbroken Events that does eventually conclude within the period of interest*/
drop table IF EXISTS #REQUESTS_BUILD
select LA_CODE
, [ID]
, Der_Age_EndDate
, Event_Start_Date 
, CASE WHEN Event_End_Date is NULL then CAST( GETDATE() AS Date) else Event_End_Date End as Event_End_Date
, Request_Route_of_Access
, Event_Outcome
into #REQUESTS_BUILD
from  #ALL_EVENTS
where
Event_Type = 'Request'
;


---------------------------------------------------------------------------------
/*INCORPORATE 'ISLANDS AND GAPS' LOGIC INTO A BUILD OF THE FINAL REQUESTS TABLE*/
---------------------------------------------------------------------------------
/*This piece of code looks at all of the Requests recorded against a Client to try and determine whether any Request Events need to be clustered together
and be counted as one distinct Request.

By ordering the Requests data chronologically earliest to latest for each Client (by LA), it is then possible to query the time elapsed between the End Date
of one Request Event and the Start Date of another Request Event - for those Clients that have more than one in the period of interest.

Code allows for breaks of 4 days, between one Request event ending and a subsequent one starting (see 'DATEADD' syntax). This threshold accounts for long weekends
and was agreed in collaboration with analytical colleagues on the LA working group. Any 'Gap' longer than 4 days is considered too long and any activity after this
point constitutes a new 'Island' or Cluster.

IslandStartInd = a flag indicating the beginning of a new Cluster for that Client (by LA)
IslandID = the rolling count of different Request Clusters per Client*/

drop table IF EXISTS #REQUESTS_With_Count
SELECT distinct a.*
, Islands.IslandID as [REQUEST_COUNT]
, MIN(a.Event_Start_Date) OVER (PARTITION BY a.LA_CODE, a.[ID], Islands.IslandID) as [MIN_START_DATE]
into #REQUESTS_With_Count
FROM #REQUESTS_BUILD a
inner join
    (
    SELECT
        *,
        CASE WHEN Groups.PreviousEndDate >= DATEADD(DAY, -4, Event_Start_Date) THEN 0 ELSE 1 END AS IslandStartInd,
        SUM(CASE WHEN Groups.PreviousEndDate >= DATEADD(DAY, -4, Event_Start_Date) THEN 0 ELSE 1 END) OVER (partition by LA_CODE, [ID] ORDER BY Groups.[ID], Groups.DRN) AS IslandId
    FROM
    (
        SELECT
			DENSE_RANK() OVER (partition by LA_CODE, [ID] ORDER BY Event_Start_Date, Event_End_Date) AS DRN,
			LA_CODE,
			[ID],
            Event_Start_Date,
            Event_End_Date,
            LAG(Event_End_Date,1) OVER (partition by LA_CODE, [ID] ORDER BY Event_Start_Date,Event_End_Date) AS PreviousEndDate
        FROM
            #REQUESTS_BUILD
    ) Groups
) Islands
on a.[ID] = Islands.[ID] and a.Event_Start_Date = Islands.Event_Start_Date and a.Event_End_Date = Islands.Event_End_Date
order by a.LA_CODE, a.[ID], a.Event_Start_Date, Islands.IslandID
;




------------------
----CONFLICTING ROA
-------------------

----Same Request Cluster for the same client at the same LA, containing different Route Of Access
--drop table IF EXISTS #CONFLICTING_ROA
--select CONC, count(CONC) as [COUNT]
--into #CONFLICTING_ROA
--from
--(
--select Concat(LA_CODE, [ID], REQUEST_COUNT) as [CONC], Request_Route_of_Access
--from #REQUESTS_With_Count
--group by Concat(LA_CODE, [ID], REQUEST_COUNT), Request_Route_of_Access
--) a
--group by CONC
--having count(CONC) > 1
--order by 2 desc

----Analysis of the individual rows within #CONFLICTING_ROA, to see which ROAs are conflicting most
--select distinct LA_CODE, [ID], REQUEST_COUNT, Request_Route_of_Access
--from #REQUESTS_With_Count
--where Concat(LA_CODE, [ID], REQUEST_COUNT) in
--(
--select [CONC]
--from #CONFLICTING_ROA
--)
--order by LA_CODE, [ID]



-------------------------------------------------------------



/*Find the latest Event End Date associated with each newly-clustered Request event and pull only this through, as 'Cluster End Date'
the Event Outcome on the last record in the Request cluster will be referred back to in cases where no sequel to the Request can be found in the onward chronology
So we now have Request Clusters with Start and End dates potentially taken from different Request events
NOTE: In this code, conflicting ROUTE OF ACCESS's will be ignored and the ROA on the latest event in the Request cluster is all that is kept*/
drop table IF EXISTS #REQUESTS
select distinct LA_CODE, [ID], Der_Age_EndDate, MIN_START_DATE as [Cluster_Start_Date], Event_End_Date as [Cluster_End_Date], Request_Route_of_Access, Event_Outcome, REQUEST_COUNT
into #REQUESTS
from 
(
select *,
DENSE_RANK() OVER (partition by LA_CODE, [ID], REQUEST_COUNT ORDER BY Event_End_Date DESC) AS RN -- DESCENDING so RN '1' is always the option to filter for
from #REQUESTS_With_Count
where (Event_End_Date between '2023-04-01' and '2023-12-31')
) a
where RN = 1
order by LA_CODE, [ID], MIN_START_DATE, REQUEST_COUNT
;


-----------------------------
/*FILTERING FOR NEW CLIENTS*/
-----------------------------

/*STS001 only captures Requests for New Clients. The distinction here is all Clients who did not have an open/ongoing
Long Term Support Service in place at the time that the Request Event started*/

--Create table of Clients in receipt of LTS in the #ALL_EVENTS table
drop table if exists #Service_Events;
select LA_Code 
,[ID]
,Service_Type
,Event_Start_Date
,Event_End_Date
into #Service_Events
from #ALL_EVENTS
where Service_Type in 
(
'Long Term Support: Nursing Care',
'Long Term Support: Residential Care',
'Long Term Support: Community',
'Long Term Support: Prison'
)
group by
LA_Code 
,[ID]
,Service_Type
,Event_Start_Date
,Event_End_Date
;


--Find Request clusters where Client has an Open/Ongoing LTS
--i.e. where Request cluster starts between a Service Start and End Date, or (in case of open-ended/ongoing Services) after/on Service Start Date 
drop table if exists #ONGOING
select LA_CODE, [ID], Cluster_Start_Date, Cluster_End_Date, Request_Route_of_Access, Event_Outcome, REQUEST_COUNT
into #ONGOING
from
(
select a.*
,b.[ID] as [Service_ID]
,b.Event_Start_Date as Service_Start_Date 
,b.Event_End_Date as Service_End_Date
,b.Service_Type
,case when a.Cluster_Start_Date between b.Event_Start_Date and b.Event_End_Date then 1
when (a.Cluster_Start_Date >= b.Event_Start_Date and b.Event_End_Date is null) then 1
else 0
end as Service_Flag
from #REQUESTS a
left join #Service_Events b
on a.[ID] = b.[ID] and a.LA_Code = b.LA_Code
where b.[ID] is not null
) x
where Service_Flag = 1
;




--Only bring forward the Request clusters for New Clients i.e. no open/ongoing Services
drop table if exists #REQUESTS_NEW_CLIENTS
select a.*
into #REQUESTS_NEW_CLIENTS
from #REQUESTS a
left join #ONGOING b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Cluster_Start_Date = b.Cluster_Start_Date and a.Cluster_End_Date = b.Cluster_End_Date
and a.Request_Route_of_Access = b.Request_Route_of_Access and a.Event_Outcome = b.Event_Outcome and a.REQUEST_COUNT = b.REQUEST_COUNT
where b.[ID] is NULL
;


---------------------------
/*FIND SEQUEL TO REQUESTS*/
---------------------------

-----------------------------------------------------------------------------------------
/*PART 1: APPLY EVENT OUTCOME HIERARCHY TO REQUESTS WITH MULTIPLE CONFLICTING OUTCOMES*/
-----------------------------------------------------------------------------------------

/* this can occur in the data where Request event rows for the same Clients have identical End Dates but different
Event Outcomes. In most cases, the 'Select Latest version of each event using bespoke Event ID' process earlier on
will correct these but in certain scenarios Events won't be captured by that process */

--Join in the Event Hierarchy reference data
drop table if exists #EVENT_OUTCOME_HIERARCHY
select a.*
, CASE WHEN b.Event_Outcome_Hierarchy is NULL then 99
else b.Event_Outcome_Hierarchy END as 'Event_Outcome_Hierarchy'
into #EVENT_OUTCOME_HIERARCHY
from #REQUESTS_NEW_CLIENTS a
left join #REF_Event_Outcome_Hierarchy b on a.Event_Outcome = b.Event_Outcome
;



--Select the highest ranking Event Outcome in hierarchy for each Request cluster
drop table if exists #REQUESTS_NEW_CLIENTS_DeDupe
select a.*
into #REQUESTS_NEW_CLIENTS_DeDupe
from #EVENT_OUTCOME_HIERARCHY a
inner join
(
select *
, DENSE_RANK() OVER (partition by LA_CODE, [ID], REQUEST_COUNT ORDER BY Event_Outcome_Hierarchy ASC) AS RN
from #EVENT_OUTCOME_HIERARCHY
) b
on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.REQUEST_COUNT = b.REQUEST_COUNT and a.Request_Route_of_Access = b.Request_Route_of_Access and a.Event_Outcome_Hierarchy = B.Event_Outcome_Hierarchy
where b.RN = 1
;


---------------------------------------------------------------------------
/*PART 2: SEARCH CLIENTS ONWARD EVENT ACTIVITY TO INFER SEQUEL TO REQUEST*/
---------------------------------------------------------------------------

/*Join all Client Request events to all of their subsequent Event activity (Requests, Assessments, Reviews and Services) from the #ALL_EVENTS table
This allows us to see what events were associated to each Client from the day that their Request finished, in order to determine the Sequel to each Request.
Each Request Cluster is LEFT JOINed, creating rows that contain the details of the Request cluster, along with details of each follow-on Event.
e.g. if a client has 1 Request in the period (Request1) and after this ended they had (in date order) an Assessment, then a Service and then a Review in the period there will
be 3 rows inserted in the table below:
1) Request1 details + Assessment details
2) Request1 details + Service details
3) Request1 details + Review details
*/
drop table if exists #REQUEST_SEQUELS
select a.*
,b.LA_CODE as 'Sequel_LA_Code', b.[ID] as 'Sequel_ID', b.Event_Start_Date as 'Sequel_Event_Start_Date', 
b.Event_End_Date as 'Sequel_Event_End_Date', b.Event_Type as 'Sequel_Event_Type', b.Service_Type as 'Sequel_Service_Type', b.Service_Component as 'Sequel_Service_Component'
, b.Event_Outcome as 'Sequel_Event_Outcome'
,DENSE_RANK() over (Partition by a.LA_CODE, a.[ID], a.REQUEST_COUNT order by b.Event_Start_Date) as Rn
into #REQUEST_SEQUELS
from #REQUESTS_NEW_CLIENTS_DeDupe a
left join #ALL_EVENTS b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID]
where b.Event_Start_Date >= a.Cluster_End_Date
order by a.LA_CODE, a.[ID], a.Cluster_Start_Date, b.Event_Start_Date
;



/*Remove any instances of the same ST_Max itself appearing again in the sequel chronology
this will sometimes happen due to the clustering of dates (onwards events will sometimes start on same day as cluster end date)*/
delete from #REQUEST_SEQUELS
where Sequel_Event_Type = 'Request' and Cluster_Start_Date = Sequel_Event_Start_Date
or Sequel_Event_Type = 'Request' and Cluster_End_Date = Sequel_Event_End_Date
;



--------------------------------------------------------------
/* 2.1: FIND THOSE REQUEST EVENTS WITH NO FURTHER CHRONOLOGY*/
--------------------------------------------------------------

/*Some Request events no further records in CLD, and so don't appear in #REQUEST_SEQUELS table
These are staged here and then added to the final #STS001 table, labelled as having no further records in chronology
If these aren't moved into the #STS001 table a significant number of Request events are lost*/
drop table if exists #NO_SEQUEL_CHRONOLOGY
select a.*
into #NO_SEQUEL_CHRONOLOGY
from #REQUESTS_NEW_CLIENTS_DeDupe a
left join #REQUEST_SEQUELS b
on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and  a.Cluster_Start_Date = b.Cluster_Start_Date and  
a.Cluster_End_Date = b.Cluster_End_Date and a.Event_Outcome = b.Event_Outcome and a.REQUEST_COUNT = b.REQUEST_COUNT
where b.LA_CODE is NULL
;



--Remove these No Sequel chronology events from the #REQUESTS_NEW_CLIENTS table
delete a
from #REQUESTS_NEW_CLIENTS_DeDupe a
left join #REQUEST_SEQUELS b
on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and  a.Cluster_Start_Date = b.Cluster_Start_Date and  
a.Cluster_End_Date = b.Cluster_End_Date and a.Event_Outcome = b.Event_Outcome and a.REQUEST_COUNT = b.REQUEST_COUNT
where b.LA_CODE is NULL
;


/*Insert the No Chronology records into final #STS001 table with bespoke FINAL_OUTCOME so they can be identified
in the final table. Firstly insert where Event Outcome CAN be mapped to SALT, and then where it can't (Unable To Classify)*/

--Create #STS001 Table
drop table if exists #STS001
;
create table #STS001
(
LA_CODE varchar(20)
,[ID] varchar(200)
,[AGE] varchar(20)
,[ROUTE_Of_ACCESS] varchar(200)
,FINAL_OUTCOME varchar (200)
,FINAL_OUTCOME_MAPPED varchar (200)
,Record_Type int
)
;

/*Insert the No Chonology records into #STS001, where Event Outcome maps to SALT descriptions i.e. valid Event Outcome
Use prefix 'No_Chronology' plus Event Outcome of Request Event to create FINAL_OUTCOME column
Use prefix 'No_Chronology' plus Event Outcome mapped to #REF_SEQUEL_MAPPING to create FINAL_OUTCOME_MAPPED column
*/
insert into #STS001
select a.LA_CODE, a.[ID], a.Der_Age_EndDate as [AGE], a.Request_Route_of_Access as [ROUTE_Of_ACCESS]
, 'No_Chronology_'+a.Event_Outcome as 'FINAL_OUTCOME'
, 'No_Chronology_'+b.Mapping_Description as 'FINAL_OUTCOME_MAPPED'
, '1' as 'Record_Type'
from #NO_SEQUEL_CHRONOLOGY a
left join #REF_SEQUEL_MAPPING b on a.Event_Outcome = b.Event_Outcome
where b.Mapping_Description is not NULL
;

--Insert the remaining No Chonology records into #STS001, where Event Outcome does not map to SALT descriptions i.e. Invalid Event Outcome
insert into #STS001
select a.LA_CODE, a.[ID], a.Der_Age_EndDate as [AGE], a.Request_Route_of_Access as [ROUTE_Of_ACCESS]
, 'No_Chronology_'+a.Event_Outcome as 'FINAL_OUTCOME'
, 'No_Chronology_Unable_To_Classify' as 'FINAL_OUTCOME_MAPPED'
, '1' as 'Record_Type'
from #NO_SEQUEL_CHRONOLOGY a
left join #REF_SEQUEL_MAPPING b on a.Event_Outcome = b.Event_Outcome
where b.Mapping_Description is NULL 
;



----------------------------------------------------------------------------------------
/* 2.2: FIND THE CORRECT SEQUEL TO THE REQUEST EVENTS THAT *DO* HAVE ONWARD CHRONOLOGY*/
----------------------------------------------------------------------------------------

-------------------------
/*Clustering of Sequels*/
-------------------------
/*This code creates a process called 'Create Cluster' where Sequel Events that begin less than 4 days after the previous Sequel Event ending are flagged '1' (to include)

The 'In_Scope' field created flags whether or not the onward chronology following the Request is considered to be related to the Request in question. If the first event 
after the Request ended is >4 weeks after, this chronology is considered to be not in scope as too much time has elapsed.

The 'In_Chain' field created flags whether or not a sequel event is still part of an unbroken chain of events following the Request (>3 day gap breaks the chain/cluster)
*/

drop table IF EXISTS #CLUSTER;
with Create_Cluster as
(
  SELECT *,
    CASE WHEN 
     DATEDIFF(
       DAY, 
       LAG(Sequel_Event_End_Date) OVER (PARTITION BY LA_Code, [ID], REQUEST_COUNT ORDER BY Sequel_Event_Start_Date) , 
       Sequel_Event_Start_Date
     ) > 3 THEN 0   
	 ELSE 1 END AS Flag -- Build chain/cluster of sequel events, with gap of no more than 4 days between
  FROM #REQUEST_SEQUELS
)
(select *,
MIN(In_Chain) OVER (PARTITION BY LA_CODE, [ID], REQUEST_COUNT ORDER BY Sequel_Event_Start_Date) as In_Scope -- Use the [In_Chain] flag built below to determine if the Request has any sequel chronology in scope for analysis 
into #CLUSTER
from
(
SELECT *,
CASE 
WHEN Sequel_Event_End_Date is NULL and Rn = 1 then 1 --mitigates issue with Open events tripping up the logic 
WHEN DATEDIFF (DAY, Cluster_End_Date, Sequel_Event_Start_Date) > 28 and Rn = 1 then 0 -- if the first Event in chronology is more than 4 weeks after Request then no chronology is in scope
ELSE MIN(flag) OVER (PARTITION BY LA_CODE, [ID], REQUEST_COUNT ORDER BY Sequel_Event_Start_Date) END as In_Chain
FROM Create_Cluster
) x
)
ORDER BY [ID], REQUEST_COUNT
;




/*Addition of a flag that signifies a 'break' in the series when another Request Event is encountered in the chronology (Cluster_No_Request flag)

A more recent Request should supplant and supersede the existing one, so the chronology search is stopped at this stage if Cluster_No_Request flag does not = 1
The superseded Request cluster gets staged into #STS001 at the end of the process

This table build also brings through the 'Hierarchy' column from REF data to allow for subsequent selection of the highest ranking Service (lowest Hierarchy number) 
using a join to the #REF_Service_Type table, where more than one Service appears in a Request Sequel cluster. Where no Service Events are encountered in the chronology,
i.e. sequel activity following the Request only contains Assessments, Reviews, Requests then the CASE statement sets these all as a Hierarchy of '99'. */
drop table IF EXISTS #REQUESTS_WITH_BREAKS;
select b.*
, CASE WHEN c.Hierarchy is NULL then 99 else c.Hierarchy end as [Hierarchy]
into #REQUESTS_WITH_BREAKS
from
(
select *,
MIN([Request_Break]) OVER (PARTITION BY LA_CODE, [ID], REQUEST_COUNT ORDER BY Sequel_Event_Start_Date) AS [Cluster_No_Request] -- If sequel cluster contains another Request this breaks the chain
from
(
select *,
CASE
when Sequel_Event_Type like 'Request' then 0 else 1 end as [Request_Break]
from #CLUSTER
) a
) b
left join #REF_Service_Type c on b.Sequel_Service_Type = c.Service_Type
where b.In_Scope = 1 and b.Cluster_No_Request = 1
;



----------------------
/*Service Chronology*/
----------------------
/*Choose the lowest Hierarchy (i.e. highest ranking Service) against each Request Sequel cluster in cases where at least one Service Event 
was found in the chronology (Cluster_Outcome not '99')*/
drop table IF EXISTS #FIND_NEXT_SERVICES
select distinct a.LA_CODE, a.[ID], a.Der_Age_EndDate, a.Request_Route_of_Access, a.Cluster_Start_Date, a.Cluster_End_Date, a.Event_Outcome, a.REQUEST_COUNT
, a.Sequel_Service_Type as [FINAL_OUTCOME]
into #FIND_NEXT_SERVICES
from #REQUESTS_WITH_BREAKS a
inner join
(
select LA_CODE, [ID], REQUEST_COUNT, MIN([Hierarchy]) as [Cluster_Outcome]
from #REQUESTS_WITH_BREAKS
group by LA_CODE, [ID], REQUEST_COUNT
) b
on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.REQUEST_COUNT = b.REQUEST_COUNT and a.Hierarchy = b.Cluster_Outcome
where Cluster_Outcome != 99
;



---------------------------
/*TABLE BUILD FOR STS002A*/
---------------------------
/*Create another version of #FIND_NEXT_SERVICES above, filtered only where the Final Outcome was 'ST-Max' and the 
Sequel_Event_Start_Date is pulled through (i.e. beginning of the reablement)
This will form the cohort of ST-Max events for STS002a
Table writes to a permanent SQL table so STS002a code script can join to it*/
drop table IF EXISTS [ASC_Sandbox].[SALT_STS002a_Cohort]
select distinct a.LA_CODE, a.[ID], a.Cluster_Start_Date, a.Cluster_End_Date, a.Event_Outcome,  a.REQUEST_COUNT
, a.Sequel_Event_Start_Date
, a.Sequel_Service_Type as [FINAL_OUTCOME]
into [TABLE NAME] --Write as a permanent table to be used as the STS002 ST-Max cohort
from #REQUESTS_WITH_BREAKS a
inner join
(
select LA_CODE, [ID], REQUEST_COUNT, MIN([Hierarchy]) as [Cluster_Outcome]
from #REQUESTS_WITH_BREAKS
group by LA_CODE, [ID], REQUEST_COUNT
) b
on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.REQUEST_COUNT = b.REQUEST_COUNT and a.Hierarchy = b.Cluster_Outcome
where Cluster_Outcome != 99
and a.Sequel_Service_Type = 'Short Term Support: ST-Max'
;



--Insert into Final table from #FIND_NEXT_SERVICES, using the FINAL_OUTCOME field created in #FINS_NEXT_SERVICES table above
insert into #STS001
select LA_CODE, [ID], Der_Age_EndDate as [AGE], Request_Route_of_Access as [ROUTE_Of_ACCESS]
, FINAL_OUTCOME
, FINAL_OUTCOME as 'FINAL_OUTCOME_MAPPED'
,'2' as 'Record_Type'
from #FIND_NEXT_SERVICES
;



--------------------------
/*NON-SERVICE CHRONOLOGY*/
--------------------------
/*Extract all the Request Sequels where no Service Event is present in the Sequel chronology (Cluster_Outcome = 99)
This is either because the Client has no onward Services in their onward Event activity, or the Service(s) they do have are not part of
the sequel chain of Events following the Request ending (see Islands and Gaps script above for further info on the date thresholds)

The Assessment/Review events associated with these 'No Service Found' type of sequels can still be analysed to see if any further information
can be gleaned from their Event Outcomes before staging into the final table (i.e do they have any 'NFA' type Event Outcomes recorded?)
which may give us more useful information than simply defaulting back to the Event Outcome of the initial Request Event*/
drop table IF EXISTS #FIND_NEXT_OTHER
select distinct a.LA_CODE, a.[ID], a.Der_Age_EndDate, a.Request_Route_of_Access, a.Cluster_Start_Date, a.Cluster_End_Date, a.Event_Outcome,  a.REQUEST_COUNT
, a.Sequel_Event_Type
, a.Sequel_Event_Start_Date
, a.Sequel_Event_End_Date
, a.Sequel_Event_Outcome --this needs adding now as we need to evaluate the outcome of these Assess/Request rows but it may introduce duplicates
, DENSE_RANK() over (Partition by a.LA_CODE, a.[ID], a.REQUEST_COUNT order by a.Sequel_Event_End_Date desc) as Rn
into #FIND_NEXT_OTHER
from #REQUESTS_WITH_BREAKS a
inner join
(
select LA_CODE, [ID], REQUEST_COUNT, MIN([Hierarchy]) as [Cluster_Outcome]
from #REQUESTS_WITH_BREAKS
group by LA_CODE, [ID], REQUEST_COUNT
) b
on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.REQUEST_COUNT = b.REQUEST_COUNT and a.Hierarchy = b.Cluster_Outcome
where Cluster_Outcome = 99
;



/*In these clusters where no Service Event is present, extract any clusters with No Further Action / End Of Life Care
(Mapping_Code = 1 as per 'REF_SEQUEL_MAPPING') type of outcomes in the sequel activity (choosing the latest End Date 
where numerous NFA outcomes are returned). This enables the Sequel to be designated an NFA outcome as per SALT, rather than the default No Service Found*/
drop table IF EXISTS #FIND_NEXT_OTHER_NFA
select a.LA_CODE, a.[ID], a.Der_Age_EndDate, a.Request_Route_of_Access, a.Cluster_Start_Date, a.Cluster_End_Date, a.REQUEST_COUNT, a.Sequel_Event_Outcome
, count(a.[ID]) OVER (Partition by a.LA_CODE, a.[ID], a.REQUEST_COUNT) as [NFA_Count]
into #FIND_NEXT_OTHER_NFA
from #FIND_NEXT_OTHER a
inner join 
(
select LA_CODE, [ID], REQUEST_COUNT, MIN([Rn]) as [Cluster_Outcome]
from #FIND_NEXT_OTHER a
left join #REF_SEQUEL_MAPPING b
on a.Sequel_Event_Outcome = b.Event_Outcome
where b.Mapping_Code = 1
group by LA_CODE, [ID], REQUEST_COUNT
) b 
on a.LA_CODE = b.[LA_CODE] and a.[ID] = b.[ID] and a.REQUEST_COUNT = b.REQUEST_COUNT and a.Rn = b.Cluster_Outcome
;



/*Stage these outcomes into the final #STS001 table as being the final sequel outcome for these Requests
NOTE: when there are conflicting types of NFA for the same Request Event, this is over-written as 'NFA- Other'
which maps to 'No service provided - other reason' in the SALT mapping*/
insert into #STS001
select distinct a.LA_CODE, a.[ID], a.Der_Age_EndDate as [AGE], a.Request_Route_of_Access as [ROUTE_Of_ACCESS]
, CASE WHEN NFA_Count = 1 THEN a.Sequel_Event_Outcome
  ELSE 'NFA- Other' 
  END as 'FINAL_OUTCOME'
, CASE WHEN NFA_Count = 1 THEN b.Mapping_Description
  ELSE 'No Services Provided - other reason'
  END as 'FINAL_OUTCOME_MAPPED'
,'3' as 'Record_Type'
from #FIND_NEXT_OTHER_NFA a
left join #REF_SEQUEL_MAPPING b on a.Sequel_Event_Outcome = b.Event_Outcome
;




/*In these #FIND_NEXT_OTHER sequel chains where no Service Event is present, extract any remaining outcomes where no further information can be gleaned
from the Event Outcome of the sequel events i.e. the Event Outcomes on any of the Assessments/Review rows were not useable for the purposes of STS001 categorisation 
These will default back to the Event Outcome of the original Request for the sequel derivation, in lieu of nothing more definitive being possible to ascertain from the chronology*/
drop table IF EXISTS #FIND_NEXT_OTHER_No_Outcome
select distinct a.LA_CODE, a.[ID], a.Der_Age_EndDate, a.Request_Route_of_Access, a.REQUEST_COUNT, a.Event_Outcome
into #FIND_NEXT_OTHER_No_Outcome
from #FIND_NEXT_OTHER a
left join #FIND_NEXT_OTHER_NFA b
on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.REQUEST_COUNT = b.REQUEST_COUNT
where b.LA_CODE is NULL
;



/*insert into final STS001 table, with the prefix 'No Service Found' followed by the original Event Outcome to create FINAL_OUTCOME
column and prefix 'No Service Found' plus Event Outcome, mapped to #REF_SEQUEL_MAPPING, to create FINAL_OUTCOME_MAPPED*/
insert into #STS001
select a.LA_CODE, a.[ID], a.Der_Age_EndDate, a.Request_Route_of_Access
, 'No Service Found_'+a.Event_Outcome as 'FINAL_OUTCOME'
, CASE WHEN b.Mapping_Code = 1 THEN 'No Service Found_'+b.Mapping_Description
  ELSE 'No Service Found'
  END as 'FINAL_OUTCOME_MAPPED'
, '4' as 'Record_Type'
from #FIND_NEXT_OTHER_No_Outcome a
left join #REF_SEQUEL_MAPPING b on a.Event_Outcome = b.Event_Outcome
;




---------------------------
/*CHRONOLOGY NOT IN-SCOPE*/
---------------------------
/*Extract the remaining Request events that were IN the #CLUSTER table but not the #REQUEST_WITH_BREAKS table
These are effectively any Request clusters that contain some onward event activity, but this activity is out of scope for consideration, either:
a) Flagged '0' in the [In_Scope] flag i.e. the first Event that appears in the Clients event chronology following the end of the Request 
   was too long after the Request ended to be considered related/connected
b) Flagged '0' in the [Cluster_No_Request] flag i.e. another separate Request Event was encountered in the chronology, superceding the initial event

These Request events still need staging into the final STS001 table, even though no sequel events could be found, otherwise Request events are left
unaccounted for and lost in the overall headline Request counts
*/
drop table IF EXISTS #FIND_NEXT_OUT_OF_SCOPE
select distinct a.LA_CODE, a.[ID], a.Der_Age_EndDate, a.Request_Route_of_Access,  a.Cluster_Start_Date, a.Cluster_End_Date, a.Event_Outcome
into #FIND_NEXT_OUT_OF_SCOPE
from #CLUSTER a
left join #REQUESTS_WITH_BREAKS b
on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Cluster_Start_Date = b.Cluster_Start_Date and a.Cluster_End_Date = b.Cluster_End_Date and a.Event_Outcome = b.Event_Outcome
where b.LA_CODE is NULL
;


/*Insert these into final #STS001 table
Use prefix 'No_Chronology' plus Event Outcome from Request event as the FINAL_OUTCOME
Use prefix 'No_Chronology' plus Event Outcome, mapped to the #REF_SEQUEL_MAPPING table, as the FINAL_OUTCOME_MAPPED
*/
insert into #STS001
select LA_CODE, [ID], Der_Age_EndDate, Request_Route_of_Access
, 'No_Chronology_'+a.Event_Outcome as 'FINAL_OUTCOME'
, 'No_Chronology_'+b.Mapping_Description as 'FINAL_OUTCOME_MAPPED'
,'5' as 'Record_Type'
from #FIND_NEXT_OUT_OF_SCOPE a
left join #REF_SEQUEL_MAPPING b on a.Event_Outcome = b.Event_Outcome
;



/*

Key for Record_Types in final STS001 table:

1 = No Chronology - the Request Event is the last event in the Clients event activity within the specified period of interest
2 = Sequel SERVICE event(s) found
3 = Sequel NON-SERVICE event(s) found (i.e. Assessment, Review) and Event Outcome of these sequels events denotes No Further Action
4 = Sequel NON-SERVICE event(s) found (i.e. Assessment, Review) but no further detail could be gleaned from the Event Outcome of these Events
5 = No useable chronology found - the Client has further activity following the end of Request event but it is not in-scope for determining sequel

*/





-------------------
--END
-------------------





-----------------------
--QUERY FOR SALT TABLES
-----------------------

select FINAL_OUTCOME, FINAL_OUTCOME_MAPPED, Record_Type, count(*)
from #STS001
group by FINAL_OUTCOME, FINAL_OUTCOME_MAPPED, Record_Type


select LA_CODE, FINAL_OUTCOME_MAPPED, count(*)
from #STS001
group by LA_CODE, FINAL_OUTCOME_MAPPED


select FINAL_OUTCOME_MAPPED, count(*)
from #STS001
group by FINAL_OUTCOME_MAPPED





