--------------------------------------------------------------
/*CODE TO RE-CREATE LTS001b: ALL TABLES 1A, 1B, 2, 3A AND 3B*/
--------------------------------------------------------------



/* Final data tables are saved as:

#LTS001b_T1a_Final
#LTS001b_T1b_Final
#LTS001b_T2_Final
#LTS001b_T3a_Final
#LTS001b_T3b_Final

Queries of these tables, written in a way to extract for SALT, are included in this script at the end 
of each respective table build in turn
*/






---------------------------------------------------------------------------------------------------
/*CREATE REFERENCE TABLE #REF_SERVICE_TYPE_DELIVERY_MECH TO CATEGORISE AND RANK ITEMS FOR LTS001b*/
---------------------------------------------------------------------------------------------------
--NOTE: Check periodically to ensure the Defined List in CLD spec has not changed!
drop table if exists #REF_Service_Type_Delivery_Mech	
create table #REF_Service_Type_Delivery_Mech
(Service_Type varchar(200)
,Delivery_Mechanism varchar(200)
,SALT_Category varchar(200)
,SALT_Broad_Category varchar(200)
,Sort_Order int
,Hierarchy int)

insert into #REF_Service_Type_Delivery_Mech
(Service_Type
,Delivery_Mechanism
,SALT_Category
,SALT_Broad_Category
,Sort_Order
,Hierarchy
)
values
('Long Term Support: Nursing Care', '', 'Nursing', 'Nursing', 1, 1)
,('Long Term Support: Residential Care', '', 'Residential', 'Residential', 2, 2)
,('Long Term Support: Community', 'Direct Payment', 'Community: Direct Payment', 'Community', 3, 3)
,('Long Term Support: Community', 'CASSR Managed Personal Budget', 'Community: CASSR Managed Personal Budget', 'Community', 4, 4)
,('Long Term Support: Community', 'CASSR Commissioned Support', 'Community: CASSR Commissioned Support', 'Community', 5, 5)
,('Long Term Support: Community', '', 'Community', 'Community', 6, 6)
,('Long Term Support: Prison', 'CASSR Managed Personal Budget', 'Prison: CASSR Managed Personal Budget', 'Prison', 7, 7)
,('Long Term Support: Prison', 'CASSR Commissioned Support', 'Prison: CASSR Commissioned Support', 'Prison', 8, 8)
,('Long Term Support: Prison', '', 'Prison', 'Prison', 9, 9)
;

------------------------------------------------------------------------------------------------------------------
/*CREATE REFERENCE TABLE #REF_CARER TO ENSURE ONLY VALID 'SUPPORT FROM CARER' FIELDS COME THROUGH INTO FINAL TABLE*/
------------------------------------------------------------------------------------------------------------------
--NOTE: Check periodically to ensure the Defined List in CLD spec has not changed!
drop table if exists #REF_CARER
create table #REF_CARER
(Has_Unpaid_Carer varchar(50))
;


insert into #REF_CARER
(Has_Unpaid_Carer 
)
values
('Yes')
,('No')
,('Invalid')
;


----------------------------------------------------------------------------------------------------
/*CREATE REFERENCE TABLE #REF_ETHNICITY TO GROUP AND ORDER ETHNITICIES FOR LTS001b TABLE 3a AND 3b*/
----------------------------------------------------------------------------------------------------
--NOTE: Check periodically to ensure the Defined List in CLD spec has not changed!
drop table if exists #REF_Ethnicity
create table #REF_Ethnicity
(Ethnicity_Description varchar(200)
,Ethnicity_Group varchar(200)
,Ethnicity_Order int)

insert into #REF_Ethnicity
(Ethnicity_Description
,Ethnicity_Group
,Ethnicity_Order
)
values
('White - English, Welsh, Scottish, Northern Irish or British', 'White', 1)
,('White - Irish', 'White', 2)
,('White - Gypsy or Irish Traveller', 'White', 3)
,('White - Roma', 'White', 4)
,('White - Any other White background', 'White', 5)
,('Mixed or multiple ethnic groups - White and Black Caribbean', 'Mixed / multiple ethnic groups', 6)
,('Mixed or multiple ethnic groups - White and Black African', 'Mixed / multiple ethnic groups', 7)
,('Mixed or multiple ethnic groups - White and Asian', 'Mixed / multiple ethnic groups', 8)
,('Mixed or multiple ethnic groups - Any other Mixed or multiple ethnic background', 'Mixed / multiple ethnic groups', 9)
,('Asian or Asian British - Indian', 'Asian / Asian British', 10)
,('Asian or Asian British - Pakistani', 'Asian / Asian British', 11)
,('Asian or Asian British - Bangladeshi', 'Asian / Asian British', 12)
,('Asian or Asian British - Chinese', 'Asian / Asian British', 13)
,('Asian or Asian British - Any other Asian background', 'Asian / Asian British', 14)
,('Black, Black British, Caribbean or African - African', 'Black / African / Caribbean / Black British', 15)
,('Black, Black British, Caribbean or African - Caribbean', 'Black / African / Caribbean / Black British', 16)
,('Black, Black British, Caribbean or African - Any other Black, Black British or Caribbean background', 'Black / African / Caribbean / Black British', 17)
,('Other ethnic group - Arab', 'Other Ethnic Group', 18)
,('Other ethnic group - Any other ethnic group', 'Other Ethnic Group', 19)
,('No data - Refused', 'No Data', 20)
,('No data - Undeclared or Not known', 'No Data', 21)
;


-------------------------------------------------------------------------------------------
/*CREATE REFERENCE TABLE #REF_PSR TO ENSURE ONLY VALID PSRs COME THROUGH INTO FINAL TABLE*/
-------------------------------------------------------------------------------------------
--NOTE: Check periodically to ensure the Defined List in CLD spec has not changed!
drop table if exists #REF_PSR
create table #REF_PSR
(Primary_Support_Reason varchar(200))
;


insert into #REF_PSR
(Primary_Support_Reason
)
values
('Physical Support: Access & mobility only')
,('Physical Support: Personal care support')
,('Sensory Support: Support for visual impairment')
,('Sensory Support: Support for hearing impairment')
,('Sensory Support: Support for dual impairment')
,('Support with Memory & Cognition')
,('Learning Disability Support')
,('Mental Health Support')
,('Social Support: Substance misuse support')
,('Social Support: Asylum seeker support')
,('Social Support: Support for Social Isolation/Other')
,('Social Support: Support to Carer')
,('Unknown')
;





------------------------------------------------------------------------------
/*FILTER DATA APPROPRIATELY FOR LTS001b INDIVIDUALS AND SELECT SNAPSHOT DATE*/
------------------------------------------------------------------------------
DECLARE
  @SnapshotDate DATE
;


SET @SnapshotDate = '2023-12-31'  -- Set this further down script as well (3 other places in total)
;

drop table if exists #LTS001b_Build
select a.*
, CAST((concat(Der_Birth_Year, '-', Der_Birth_Month, '-', '01')) as DATE) as [Der_DOB] -- Derived using 1st month as an arbitrary date
, FLOOR((DATEDIFF (DAY, (CAST(concat(Der_Birth_Year, '-', Der_Birth_Month, '-', '01') as DATE)), @SnapshotDate))/365.25) as [Der_Age_Snapshot_Date]--Derived Age as per Snapshot
, Case when Primary_Support_Reason = 'Unknown' or Primary_Support_Reason is NULL then 0 else 1 end as [Der_PSR_Known] --used to preference rows as part of de-duplication 
, Case when Has_Unpaid_Carer = 'Unknown' or Has_Unpaid_Carer is NULL then 0 else 1 end as [Der_Carer_Known] --used to preference rows as part of de-duplication 
, Case when Ethnicity = 'No data - Undeclared or Not known' or Ethnicity is NULL then 0 else 1 end as [Der_Ethnicity_Known] --used to preference rows as part of de-duplication 
into #LTS001b_Build
from [NHSD].[CLD_R1_Raw] a
------------------------------------------------------------
--New code to find any instance of a DoD in Clients entire event history that might rule them out of the cohort
left join 
(
select Der_NHS_Number_Pseudo_Traced
from [NHSD].[CLD_R1_Raw]
where Date_of_Death < @SnapshotDate
) b
on a.Der_NHS_Number_Pseudo_Traced = b.Der_NHS_Number_Pseudo_Traced
-----------------------------------------------------------
where [Service_Type] in ('Long Term Support: Nursing Care', 'Long Term Support: Residential Care', 'Long Term Support: Community', 'Long Term Support: Prison')
and Client_Type = 'Service User'
and Event_Start_Date <= @SnapshotDate --No End Date yet until amalgamated [ID] has been created
and (Date_of_Death >= @SnapshotDate OR Date_of_Death is NULL)
and (Der_Birth_Month is not NULL and Der_Birth_Year is not NULL) --Only small amount currently but they stop the CAST functions from working. See query below to extract and analyse Unknowns
and b.Der_NHS_Number_Pseudo_Traced is NULL --Unable to find a join i.e. there was no recorded death that would rule the Client out of scope
and LA_CODE in
(
'805'
,'316'
,'317'
,'205'
)
;


--/*Staging table allowing for analysis of Unknown Age records*/
--drop table if exists #LTS001b_UnknownAges
--select *
--into #LTS001b_UnknownAges
--from [NHSD].[CLD_R1_Raw]
--where [Service_Type] in ('Long Term Support: Nursing Care', 'Long Term Support: Residential Care', 'Long Term Support: Community', 'Long Term Support: Prison')
--and Client_Type = 'Service User'
--and Event_Start_Date <= @EndDate --No End Date yet until amalgamated [ID] has been created
--and (Date_of_Death >= @StartDate OR Date_of_Death is NULL) 
--and (Der_Birth_Month is NULL or Der_Birth_Year is NULL)
--;



-----------------------------------------
/*CREATE AMALGAMATED NHS/LA IDENTIFIER*/
-----------------------------------------
/*initially, find all individuals with an NHS Number and stage into a temporary table*/                            
drop table if exists #uniquenhs
SELECT DISTINCT Der_Unique_Record_ID, Der_NHS_Number_Traced_Pseudo, Der_LA_Person_Unique_Identifier_Pseudo, 'NHS' as [Source]                                                                                                                                                     
INTO #uniquenhs                                                                                                                                                           
FROM #LTS001b_Build                                                                                                                                               
where Der_NHS_Number_Traced_Pseudo is not NULL                                                                                          
;


/*where the NHS Number is missing, pull through all individuals LA Unique ID
except in those cases where the LA Unique ID is already present and associated with an individual in #uniquenhs*/
drop table if exists #missingnhs
SELECT distinct a.Der_Unique_Record_ID, a.Der_NHS_Number_Traced_Pseudo, a.Der_LA_Person_Unique_Identifier_Pseudo, 'LA' as [Source]                                                                             
INTO #missingnhs                                                                                                                                                           
FROM #LTS001b_Build a                                                                                                                                                
left join #uniquenhs b on a.Der_LA_Person_Unique_Identifier_Pseudo = b.Der_LA_Person_Unique_Identifier_Pseudo                                                                                                          
where a.Der_NHS_Number_Traced_Pseudo is NULL                                                                                              
and b.Der_LA_Person_Unique_Identifier_Pseudo is NULL                                                                                     
;


/*Stack the NHS IDs and the LA IDs from the two temp tables underneath each other in a final table, as an amalgamated 'ID' field*/
drop table if exists #FINAL
select distinct Der_Unique_Record_ID, Der_NHS_Number_Traced_Pseudo as [ID], [Source]                                     
into #FINAL                                                                                                                                                                     
from #uniquenhs                                                                                                                                                           
UNION                                                                                                                                                               
select distinct Der_Unique_Record_ID, Der_LA_Person_Unique_Identifier_Pseudo as [ID], [Source]                        
from #missingnhs
;


/*Add a column to Raw table with the new ID field*/
alter table #LTS001b_Build add [ID] nvarchar (200)
GO
;
update a
set a.[ID] = b.[ID]
from #LTS001b_Build a left join #FINAL b on a.Der_Unique_Record_ID = b.Der_Unique_Record_ID
;

/*delete rows from table where [ID] is NULL
These records can not be assigned to an individual with 100% accuracy and without the risk of double-counting 
as the NHS ID is NULL and the LA ID is already present in the data associated to an NHS Number*/
delete from #LTS001b_Build
where [ID] is NULL
;

----------------------------------------------------------------------------------------------------------------------------


-------------------
/*CREATE EVENT_ID*/
-------------------
/*A bespoke Event ID is created here to pin-point unique Events in the data. This is done using a combination of several fields as a 
concatenation. CLD spec items 'Event Reference Number' (ERN) has been used previously for this but local differences of how the ERN is applied in CLD have meant
that it is not always robust enough to use a a unique event identifier.
This approach is consistent with how unique Events are created in the DHSC CLD Power BI Dashboard, although the de-duplication rules used in the
dashboard differ from the SALT methodology adhered to in this code script
NOTE: the fields used in the concatenation below are specfically for dealing with SERVICE events. The field combinations differ by Event Type*/
alter table #LTS001b_Build add [Event_ID] nvarchar(200)
GO
;
update #LTS001b_Build
set [Event_ID] = CONCAT(LA_CODE, [ID], Event_Start_Date, Client_Type, Service_Type, Service_Component, Delivery_Mechanism)
;


-------------------------------------------
/*APPLY DATE FILTER TO CREATE LTS001b_RAW*/
-------------------------------------------

--Correct End Date filter can now be added i.e. Events cannot have ended before the snapshot
--Must be done after EVENT_ID has been created for next 'UPDATED RECORDS' process to work
DECLARE
  @SnapshotDate DATE
;


SET @SnapshotDate = '2023-12-31' --set snapshot date

drop table if exists #LTS001b_Raw
select *
into #LTS001b_Raw
from #LTS001b_Build
where (Event_End_Date >= @SnapshotDate or Event_End_Date is NULL)
;




----------------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------
/*UPDATED RECORDS: PROCESS TO REMOVE 'OPEN' EVENTS SUBSEQUENTLY MARKED AS CLOSED*/
----------------------------------------------------------------------------------

/*This process is designed to remove Events that are in CLD as 'Open' as per the period of interest, but
have been supplanted/superseded by a more up-to-date edition of the record that indicates the Event has closed.

This occurs due to how the data lands and is stored i.e. records are continually stacked and no 'old' records are ever deleted or amended.

This process is based on the EVENT_ID concatenation field. For this reason, if one field in the concatenation has altered even slightly
then a new EVENT_ID has been generated and the process below will not be successful in identifying this activity as the same Event*/


/*Select the latest version of each event, as per the latest ImportDate, and move any Events recorded as closed into the #CLOSED_EVENTS table. 
Process needs to be undertaken on the #Build table initially as this contains the historical data pre-dating the period of interest*/
drop table if exists #CLOSED_EVENTS
select distinct a.EVENT_ID, b.Latest_Event_Submission
into #CLOSED_EVENTS
from #LTS001b_Build a
inner join 
(
select EVENT_ID, MAX(ImportDate) as 'Latest_Event_Submission'
from #LTS001b_Build
where ImportDate < '2024-02-01' -- set submission date. Only submissions within the relevant CLD submission window can be considered (e.g. for Q3 snapshot of 31/12 the last day for LA submissions is 30/01
group by EVENT_ID
) b
on a.Event_ID = b.Event_ID and a.ImportDate = b.Latest_Event_Submission
inner join #LTS001b_Raw c on a.Event_ID = c.Event_ID
where a.Event_End_Date < '2023-12-31' -- enter snapshot date
;


/*In some cases, Event IDs in the #CLOSED_EVENTS table also have a matching entry in the same latest submission that are NOT closed. 
These need flagging as not closed or 're-opened' in order that they are not removed from the LTS001a_Raw table*/
drop table if exists #REOPENED
select distinct a.EVENT_ID, b.Latest_Event_Submission
into #REOPENED
from #LTS001b_Build a
inner join #CLOSED_EVENTS b
on a.Event_ID = b.Event_ID and a.ImportDate = b.Latest_Event_Submission
where (a.Event_End_Date >= '2023-12-31' or a.Event_End_Date is NULL) --enter snapshot date
;


/*Remove from the #LTS001a_Raw table all EVENT_IDs that are IN the #CLOSED_EVENTS table and NOT IN the #REOPENED table
i.e the latest indication is that these Events have closed, and not re-opened, thus they are out of scope for this cohort*/
delete from #LTS001b_Raw
where EVENT_ID in
(
select Event_ID
from #CLOSED_EVENTS
)
and EVENT_ID not in
(
select Event_ID
from #REOPENED
) 


-------------------------------------------------------------------------------------------------------------------


-----------------------------------------------------------------------------------------
/*OVER-WRITE ANY INVALID OR UNEXPECTED ENTRIES IN THE DELIVERY MECHANISM COLUMN TO ''  */
-----------------------------------------------------------------------------------------
--Delivery Mechanism is currently NOT a mandatory field and so we can not remove records based on inaccuracy in this field
--but leaving invalid/unexpected entries in the field will cause problems with the Reference data join. 
--Solution to this is to blank out ('') any entries that are invalid or where a Delivery Mechanism is not expected (Nursing and Res events)
update a
set a.Delivery_Mechanism = 
(CASE WHEN b.Delivery_Mechanism is not NULL and a.Service_Type in ('Long Term Support: Community', 'Long Term Support: Prison') then a.Delivery_Mechanism 
	  ELSE '' 
	  end)
from #LTS001b_Raw a
left join #REF_Service_Type_Delivery_Mech b on trim (a.[Service_type]) = trim (b.[Service_Type])
and trim (a.Delivery_Mechanism) = trim (b.[Delivery_Mechanism])
;





----------------------------------------------------------------------------
/*TABLE 1a INITIAL BUILD: AGED 18-64 BY PSR AND SETTING/DELIVERY MECHANISM*/
----------------------------------------------------------------------------
--Create T1a table and add relevant fields from Reference data
drop table if exists #LTS001b_T1a
select a.*
,b.[Sort_Order]
,b.[Hierarchy]
into #LTS001b_T1a
from #LTS001b_Raw a
left join #REF_Service_Type_Delivery_Mech b on trim (a.[Service_type]) = trim (b.[Service_Type])
and trim (a.Delivery_Mechanism) = trim (b.[Delivery_Mechanism])
where a.Der_Age_Snapshot_Date between 18 and 64 -- Using the Derived Age field created from Month and Year of Birth
;


------------------------------------------------------
/*TABLE 1a PROCESSING, FILTERING AND DE-DUPLICATION*/
------------------------------------------------------

/* In SALT each Client can only be counted once in each LTS table so de-duplication routines are needed to achieve this.
Code below chooses the record with the lowest 'Rank' in Service_Type/Delivery_Mech Hierarchy as per the REF data
and also tries to deal with instances of multiple PSR on the same ID. This is done by selecting Known PSRs over Unknown,
then from these the PSR on the most recent EVENT_START_DATE, and then where still multiple options, the most recent LOAD_DATE*/


--The code has to work in this specific sequence in order to be correct:
--1. For each combination of PSR, Service Type and Delivery Mech - choose the lowest Hierarchy against each ID
-- and then of this cohort
--2. Choose only Known PSR records in instances where both a Known and an Unknown exist for same LTS event (if only Unknowns exist keep these)
-- and then of this cohort
--3. Select the latest Event Start Date
-- and then of this cohort
--4. Select the latest Load Date from any remaining instances of duplicate PSRs on same ID

--5. If any duplicate PSRs are still present in rows with identical ID, Hierarchy, Event Start Date and Import Date, default each instance to Unknown PSR

-- with this final cohort count the distinct IDs by LA, PSR, Service Type and Delivery Mech

--1. Pull out lowest Hierarchy / 'RANK' (a Nursing setting 'trumps' Community setting etc for the same client)
drop table if exists #LTS001b_T1a_MinRank
SELECT LA_Code, [ID], Min(Hierarchy) as [RANK]
into #LTS001b_T1a_MinRank
FROM #LTS001b_T1a
GROUP BY LA_Code, [ID]
;

--2. Select only records with a Known PSR if both Known and Unknown exist on same [ID] from cohort 1.
--   (code takes the highest 'Der_PSR_Known' flag where 0 = Unknown and 1 = Known)
drop table if exists #LTS001b_T1a_PSR_Known
SELECT a.LA_Code, b.[ID], b.[RANK], Max(DER_PSR_Known) as [MaxPSRKnown]
into #LTS001b_T1a_PSR_Known
FROM #LTS001b_T1a a
left join #LTS001b_T1a_MinRank b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK]
where 
b.[ID] is not NULL
GROUP BY a.LA_Code, b.[ID], b.[RANK]
;


--3. Select the latest Event Start Date of the records from cohort 2.
drop table if exists #LTS001b_T1a_MaxDate
SELECT a.LA_Code, b.[ID], [RANK], [MaxPSRKnown], max(Event_Start_Date) as [MaxDate]
into #LTS001b_T1a_MaxDate
FROM #LTS001b_T1a a
left join #LTS001b_T1a_PSR_Known b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_PSR_Known = b.[MaxPSRKnown]
where 
b.[ID] is not NULL
group by a.LA_Code, b.[ID], [RANK], [MaxPSRKnown]
;
 

 --4. Select the latest Import Date of the records from cohort 3. 
--   Create final COMBINED table
drop table if exists #LTS001b_T1a_COMBINED
SELECT a.La_Code, a.[ID], [RANK], [MaxPSRKnown], [MaxDate], max(ImportDate) as [MaxImportDate]
into #LTS001b_T1a_COMBINED
FROM #LTS001b_T1a a
left join #LTS001b_T1a_MaxDate b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_PSR_Known = b.[MaxPSRKnown] and a.Event_Start_Date = b.MaxDate
where 
b.[ID] is not NULL
group by a.La_Code, a.[ID], [RANK], [MaxPSRKnown], [MaxDate]
;


-- Pull through all the PSR, Service Type and Delivery Mech information for each [ID] in the Combined table
-- as part of this, now over-write any Invalid (as per the spec) or NULL PSRs as 'Invalid/Null'
drop table if exists #LTS001b_T1a_Final_Staging
select a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Primary_Support_Reason is NULL then 'Invalid/NULL' else c.Primary_Support_Reason END as 'Primary_Support_Reason'
, a.[ID]
into #LTS001b_T1a_Final_Staging
from #LTS001b_T1a_COMBINED a 
left join #LTS001b_T1a b on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.[RANK] = b.[Hierarchy] and a.MaxPSRKnown = b.Der_PSR_Known and a.MaxDate = b.Event_Start_Date and a.MaxImportDate = b.ImportDate
left join #REF_PSR c on b.Primary_Support_Reason = c.Primary_Support_Reason
group by a.LA_CODE, b.Service_Type, b.Delivery_Mechanism 
, CASE WHEN c.Primary_Support_Reason is NULL then 'Invalid/NULL' else c.Primary_Support_Reason END
, a.[ID]
;



-- Build a table of Duplicate records - at this stage after the previous de-duplication procedures 1-4 above this will be records
-- that are identical for the purposes of LTS001b apart from having conflicting PSRs
drop table if exists #T1a_PSR_Duplicates
select LA_CODE, Service_Type, Delivery_Mechanism, [ID], count([ID]) as [COUNT]
into #T1a_PSR_Duplicates
from #LTS001b_T1a_Final_Staging
group by LA_CODE, Service_Type, Delivery_Mechanism, [ID]
having count([ID]) > 1
;



-- Create Final LTS001b Table 1a
-- PSR is altered as part of the build to over-write any conflicting PSRs to 'Unknown' in all instances
drop table if exists #LTS001b_T1a_Final
select distinct 
a.LA_CODE
, CASE When b.[COUNT] is not NULL then 'Unknown' else a.Primary_Support_Reason End as [Primary_Support_Reason]
, a.Service_Type
, a.Delivery_Mechanism
, a.[ID]
into #LTS001b_T1a_Final
from #LTS001b_T1a_Final_Staging a
left join #T1a_PSR_Duplicates b on a.LA_code = b.LA_Code and a.Service_Type = b.Service_Type and a.Delivery_Mechanism = b.Delivery_Mechanism and a.[ID] = b.[ID]
;



-------------------------------
/*PRODUCE COUNTS FOR TABLE 1A*/
-------------------------------
select LA_CODE, Primary_Support_Reason, Service_Type, Delivery_Mechanism, count(distinct [ID])
from #LTS001b_T1a_Final
group by LA_CODE, Primary_Support_Reason, Service_Type, Delivery_Mechanism
order by LA_CODE
;


--------------------------------------------------------------------------
/*TABLE 1b INITIAL BUILD: AGED 65+ BY PSR AND SETTING/DELIVERY MECHANISM*/
--------------------------------------------------------------------------
--Create T1b table and add relevant fields from Reference data
drop table if exists #LTS001b_T1b
select a.*
,b.[Sort_Order]
,b.[Hierarchy]
into #LTS001b_T1b
from #LTS001b_Raw a
left join #REF_Service_Type_Delivery_Mech b on trim (a.[Service_type]) = trim (b.[Service_Type])
and trim (a.Delivery_Mechanism) = trim (b.[Delivery_Mechanism])
where a.Der_Age_Snapshot_Date > 64 -- Using the Derived Age field created from Month and Year of Birth
;


------------------------------------------------------
/*TABLE 1b PROCESSING, FILTERING AND DE-DUPLICATION*/
------------------------------------------------------
--SEE NOTES as as Table 1a above for full rationale


--1. Pull out lowest Hierarchy / 'RANK'
drop table if exists #LTS001b_T1b_MinRank
SELECT LA_Code, [ID], Min(Hierarchy) as [RANK]
into #LTS001b_T1b_MinRank
FROM #LTS001b_T1b
GROUP BY LA_Code, [ID]
;


--2. Select only records with a Known PSR if both Known and Unknown exist on same [ID] from cohort 1.
--   (code takes the highest 'Der_PSR_Known' flag where 0 = Unknown and 1 = Known)
drop table if exists #LTS001b_T1b_PSR_Known
SELECT a.LA_Code, b.[ID], b.[RANK], Max(DER_PSR_Known) as [MaxPSRKnown]
into #LTS001b_T1b_PSR_Known
FROM #LTS001b_T1b a
left join #LTS001b_T1b_MinRank b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK]
where 
b.[ID] is not NULL
GROUP BY a.LA_Code, b.[ID], b.[RANK]
;



--3. Select the latest Event Start Date of the records from cohort 2.
drop table if exists #LTS001b_T1b_MaxDate
SELECT a.LA_Code, b.[ID], [RANK], [MaxPSRKnown], max(Event_Start_Date) as [MaxDate]
into #LTS001b_T1b_MaxDate
FROM #LTS001b_T1b a
left join #LTS001b_T1b_PSR_Known b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_PSR_Known = b.[MaxPSRKnown]
where 
b.[ID] is not NULL
group by a.LA_Code, b.[ID], [RANK], [MaxPSRKnown]
;



--4. Select the latest Import Date of the records from cohort 3. 
--   Create final COMBINED table
drop table if exists #LTS001b_T1b_COMBINED
SELECT a.La_Code, a.[ID], [RANK], [MaxPSRKnown], [MaxDate], max(ImportDate) as [MaxImportDate]
into #LTS001b_T1b_COMBINED
FROM #LTS001b_T1b a
left join #LTS001b_T1b_MaxDate b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_PSR_Known = b.[MaxPSRKnown] and a.Event_Start_Date = b.MaxDate
where 
b.[ID] is not NULL
group by a.La_Code, a.[ID], [RANK], [MaxPSRKnown], [MaxDate]
;



-- Pull through all the PSR, Service Type and Delivery Mech information for each [ID] in the Combined table
-- as part of this, now over-write any Invalid (as per the spec) or NULL PSRs as 'Invalid/Null'
-- as leaving these populated causes duplicates to pull through into the final table
drop table if exists #LTS001b_T1b_Final_Staging
select a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Primary_Support_Reason is NULL then 'Invalid/NULL' else c.Primary_Support_Reason END as 'Primary_Support_Reason'
, a.[ID]
into #LTS001b_T1b_Final_Staging
from #LTS001b_T1b_COMBINED a 
left join #LTS001b_T1b b on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.[RANK] = b.[Hierarchy] and a.MaxPSRKnown = b.Der_PSR_Known and a.MaxDate = b.Event_Start_Date and a.MaxImportDate = b.ImportDate
left join #REF_PSR c on b.Primary_Support_Reason = c.Primary_Support_Reason
group by a.LA_CODE, b.Service_Type, b.Delivery_Mechanism 
, CASE WHEN c.Primary_Support_Reason is NULL then 'Invalid/NULL' else c.Primary_Support_Reason END
, a.[ID]
;




-- Build a table of Duplicate records - at this stage after the previous de-duplication procedures 1-4 above this will be records
-- that are identical for the purposes of LTS001b apart from having conflicting PSRs
drop table if exists #T1b_PSR_Duplicates
select LA_CODE, Service_Type, Delivery_Mechanism, [ID], count([ID]) as [COUNT]
into #T1b_PSR_Duplicates
from #LTS001b_T1b_Final_Staging
group by LA_CODE, Service_Type, Delivery_Mechanism, [ID]
having count([ID]) > 1
;


-- Create Final LTS001b Table 1b
-- PSR is altered as part of the build to over-write any conflicting PSRs to 'Unknown' in all instances
drop table if exists #LTS001b_T1b_Final
select distinct 
a.LA_CODE
, CASE When b.[COUNT] is not NULL then 'Unknown' else a.Primary_Support_Reason End as [Primary_Support_Reason]
, a.Service_Type
, a.Delivery_Mechanism
, a.[ID]
into #LTS001b_T1b_Final
from #LTS001b_T1b_Final_Staging a
left join #T1b_PSR_Duplicates b on a.LA_code = b.LA_Code and a.Service_Type = b.Service_Type and a.Delivery_Mechanism = b.Delivery_Mechanism and a.[ID] = b.[ID]
;


-------------------------------
/*PRODUCE COUNTS FOR TABLE 1b*/
-------------------------------
select LA_CODE, Primary_Support_Reason, Service_Type, Delivery_Mechanism, count(distinct [ID])
from #LTS001b_T1b_Final
group by LA_CODE, Primary_Support_Reason, Service_Type, Delivery_Mechanism
order by LA_CODE






------------------------------------------------------------------------------------------
/*TABLE 2 INITIAL BUILD: ALL AGES BY 'SUPPORT FROM CARER' AND SETTING/DELIVERY MECHANISM*/
------------------------------------------------------------------------------------------
--Create T2 table and add relevant fields from Reference data
drop table if exists #LTS001b_T2
select a.*
,b.[Sort_Order]
,b.[Hierarchy]
into #LTS001b_T2
from #LTS001b_Raw a
left join #REF_Service_Type_Delivery_Mech b on trim (a.[Service_type]) = trim (b.[Service_Type])
and trim (a.Delivery_Mechanism) = trim (b.[Delivery_Mechanism])
;


----------------------------------------------------
/*TABLE 2 PROCESSING, FILTERING AND DE-DUPLICATION*/
----------------------------------------------------
--This needs to choose the record with the lowest Service_Type/Delivery_Mech Hierarchy as per the REF data
--But also deal with potential of conflicting Support From Carer (Yes/No) on the same Pseudo ID

--1. Pull out lowest Hierarchy / 'RANK'
drop table if exists #LTS001b_T2_MinRank
SELECT LA_Code, [ID], Min(Hierarchy) as [RANK]
into #LTS001b_T2_MinRank
FROM #LTS001b_T2
GROUP BY LA_Code, [ID]
;

--2. Select only records with a Known 'Has Unpaid Carer' field if both Known and Unknown exist on same [ID] from cohort 1.
--   (code takes the highest 'Der_Carer_Known' flag where 0 = Unknown and 1 = Known)
drop table if exists #LTS001b_T2_Carer_Known
SELECT a.LA_Code, b.[ID], b.[RANK], Max(Der_Carer_Known) as [MaxCarerKnown]
into #LTS001b_T2_Carer_Known
FROM #LTS001b_T2 a
left join #LTS001b_T2_MinRank b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK]
where 
b.[ID] is not NULL
GROUP BY a.LA_Code, b.[ID], b.[RANK]
;
 

--3. Select the latest Event Start Date of the records from cohort 2.
drop table if exists #LTS001b_T2_MaxDate
SELECT a.LA_Code, b.[ID], [RANK], [MaxCarerKnown], max(Event_Start_Date) as [MaxDate]
into #LTS001b_T2_MaxDate
FROM #LTS001b_T2 a
left join #LTS001b_T2_Carer_Known b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_Carer_Known = b.[MaxCarerKnown]
where 
b.[ID] is not NULL
group by a.LA_Code, b.[ID], [RANK], [MaxCarerKnown]
;
 

--4. Select the latest Import Date of the records from cohort 3. 
--   Create final COMBINED table
drop table if exists #LTS001b_T2_COMBINED
SELECT a.La_Code, a.[ID], [RANK], [MaxCarerKnown], [MaxDate], max(ImportDate) as [MaxImportDate]
into #LTS001b_T2_COMBINED
FROM #LTS001b_T2 a
left join #LTS001b_T2_MaxDate b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_Carer_Known = b.[MaxCarerKnown] and a.Event_Start_Date = b.MaxDate
where 
b.[ID] is not NULL
group by a.La_Code, a.[ID], [RANK], [MaxCarerKnown], [MaxDate]
;


-- Pull through all the Has_Unpaid_Carer, Service Type and Delivery Mech information for each [ID] in the Combined table
drop table if exists #LTS001b_T2_Final_Staging
select a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Has_Unpaid_Carer is NULL then 'Invalid/NULL' else c.Has_Unpaid_Carer END as 'Has_Unpaid_Carer'
, a.[ID]
into #LTS001b_T2_Final_Staging
from #LTS001b_T2_COMBINED a 
left join #LTS001b_T2 b on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.[RANK] = b.[Hierarchy] and a.MaxCarerKnown = b.Der_Carer_Known and a.MaxDate = b.Event_Start_Date and a.MaxImportDate = b.ImportDate
left join #REF_CARER c on b.Has_Unpaid_Carer = c.Has_Unpaid_Carer
group by a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Has_Unpaid_Carer is NULL then 'Invalid/NULL' else c.Has_Unpaid_Carer END 
, a.[ID]
;




-- Build a table of Duplicate records - at this stage after the previous de-duplication procedures 1-4 above this will be records
-- that are identical for the purposes of LTS001a apart from having conflicting 'Has Unpaid Carer' field
drop table if exists #T2_Carer_Duplicates
select LA_CODE, Service_Type, Delivery_Mechanism, [ID], count([ID]) as [COUNT]
into #T2_Carer_Duplicates
from #LTS001b_T2_Final_Staging
group by LA_CODE, Service_Type, Delivery_Mechanism, [ID]
having count([ID]) > 1
;



-- Create Final LTS001b Table 2
-- Has_Unpaid_Carer is altered as part of the build to over-write any conflicting Carer info to 'Unknown' in all instances
drop table if exists #LTS001b_T2_Final
select distinct 
a.LA_CODE
, CASE When b.[COUNT] is not NULL then 'Unknown' else a.Has_Unpaid_Carer End as [Has_Unpaid_Carer]
, a.Service_Type
, a.Delivery_Mechanism
, a.[ID]
into #LTS001b_T2_Final
from #LTS001b_T2_Final_Staging a
left join #T2_Carer_Duplicates b on a.LA_code = b.LA_Code and a.Service_Type = b.Service_Type and a.Delivery_Mechanism = b.Delivery_Mechanism and a.[ID] = b.[ID]
;



-------------------------------
/*PRODUCE COUNTS FOR TABLE 2*/
-------------------------------
select LA_CODE, Has_Unpaid_Carer, Service_Type, Delivery_Mechanism, count(distinct [ID])
from #LTS001b_T2_Final
group by LA_CODE, Has_Unpaid_Carer, Service_Type, Delivery_Mechanism
order by LA_CODE
;





-----------------------------------------------------------------------------
/*TABLE 3a INITIAL BUILD: MALES BY ETHNICITY AND SETTING/DELIVERY MECHANISM*/
-----------------------------------------------------------------------------
--Create T3a table and add relevant fields from Reference data
drop table if exists #LTS001b_T3a
select a.*
,b.[Sort_Order]
,b.[Hierarchy]
into #LTS001b_T3a
from #LTS001b_Raw a
left join #REF_Service_Type_Delivery_Mech b on trim (a.[Service_type]) = trim (b.[Service_Type])
and trim (a.Delivery_Mechanism) = trim (b.[Delivery_Mechanism])
where a.Gender = 'Male'
;


------------------------------------------------------
/*TABLE 3a PROCESSING, FILTERING AND DE-DUPLICATION*/
------------------------------------------------------
--1. Pull out lowest Hierarchy / 'RANK'
drop table if exists #LTS001b_T3a_MinRank
SELECT LA_Code, [ID], Min(Hierarchy) as [RANK]
into #LTS001b_T3a_MinRank
FROM #LTS001b_T3a
GROUP BY LA_Code, [ID]
;

--2. Select only records with a Known Ethnicity if both Known and Unknown exist on same [ID] from cohort 1.
--   (code takes the highest 'Der_Ethnicity_Known' flag where 0 = Unknown and 1 = Known)
drop table if exists #LTS001b_T3a_Ethnicity_Known
SELECT a.LA_Code, b.[ID], b.[RANK], Max(DER_Ethnicity_Known) as [MaxEthnicityKnown]
into #LTS001b_T3a_Ethnicity_Known
FROM #LTS001b_T3a a
left join #LTS001b_T3a_MinRank b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK]
where 
b.[ID] is not NULL
GROUP BY a.LA_Code, b.[ID], b.[RANK]
;


--3. Select the latest Event Start Date of the records from cohort 2.
drop table if exists #LTS001b_T3a_MaxDate
SELECT a.LA_Code, b.[ID], [RANK], [MaxEthnicityKnown], max(Event_Start_Date) as [MaxDate]
into #LTS001b_T3a_MaxDate
FROM #LTS001b_T3a a
left join #LTS001b_T3a_Ethnicity_Known b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_Ethnicity_Known = b.[MaxEthnicityKnown]
where 
b.[ID] is not NULL
group by a.LA_Code, b.[ID], [RANK], [MaxEthnicityKnown]
;



--4. Select the latest Import Date of the records from cohort 3. 
--   Create final COMBINED table
drop table if exists #LTS001b_T3a_COMBINED
SELECT a.La_Code, a.[ID], [RANK], [MaxEthnicityKnown], [MaxDate], max(ImportDate) as [MaxImportDate]
into #LTS001b_T3a_COMBINED
FROM #LTS001b_T3a a
left join #LTS001b_T3a_MaxDate b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_Ethnicity_Known = b.[MaxEthnicityKnown] and a.Event_Start_Date = b.MaxDate
where 
b.[ID] is not NULL
group by a.La_Code, a.[ID], [RANK], [MaxEthnicityKnown], [MaxDate]
;


-- Pull through all the Ethnicity, Service Type and Delivery Mech information for each [ID] in the Combined table
drop table if exists #LTS001b_T3a_Final_Staging
select a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Ethnicity_Description is NULL then 'Invalid/NULL' else c.Ethnicity_Description END as 'Ethnicity'
, a.[ID]
into #LTS001b_T3a_Final_Staging
from #LTS001b_T3a_COMBINED a 
left join #LTS001b_T3a b on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.[RANK] = b.[Hierarchy] and a.MaxEthnicityKnown = b.Der_Ethnicity_Known and a.MaxDate = b.Event_Start_Date and a.MaxImportDate = b.ImportDate
left join #REF_Ethnicity c on b.Ethnicity = c.Ethnicity_Description
group by a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Ethnicity_Description is NULL then 'Invalid/NULL' else c.Ethnicity_Description END
, a.[ID]
;


-- Build a table of Duplicate records - at this stage after the previous de-duplication procedures 1-4 above this will be records
-- that are identical for the purposes of LTS001b apart from having conflicting Ethnicity
drop table if exists #T3a_Ethnicity_Duplicates
select LA_CODE, Service_Type, Delivery_Mechanism, [ID], count([ID]) as [COUNT]
into #T3a_Ethnicity_Duplicates
from #LTS001b_T3a_Final_Staging
group by LA_CODE, Service_Type, Delivery_Mechanism, [ID]
having count([ID]) > 1
;


-- Create Final LTS001b Table 3a
-- Ethnicity is altered as part of the build to over-write any conflicting Ethnicity to 'Unknown' in all instances
drop table if exists #LTS001b_T3a_Final
select distinct 
a.LA_CODE
, CASE When b.[COUNT] is not NULL then 'No data - Undeclared or Not known' else a.Ethnicity End as [Ethnicity]
, a.Service_Type
, a.Delivery_Mechanism
, a.[ID]
into #LTS001b_T3a_Final
from #LTS001b_T3a_Final_Staging a
left join #T3a_Ethnicity_Duplicates b on a.LA_code = b.LA_Code and a.Service_Type = b.Service_Type and a.Delivery_Mechanism = b.Delivery_Mechanism and a.[ID] = b.[ID]
;


-------------------------------
/*PRODUCE COUNTS FOR TABLE 3a*/
-------------------------------
select LA_CODE, Ethnicity, Service_Type, Delivery_Mechanism, count(distinct [ID])
from #LTS001b_T3a_Final
group by LA_CODE, Ethnicity, Service_Type, Delivery_Mechanism
order by LA_CODE
;





-----------------------------------------------------------------
/*TABLE 3b: FEMALES BY ETHNICITY AND SETTING/DELIVERY MECHANISM*/
-----------------------------------------------------------------

--Create T3b table and add relevant fields from Reference data
drop table if exists #LTS001b_T3b
select a.*
,b.[Sort_Order]
,b.[Hierarchy]
into #LTS001b_T3b
from #LTS001b_Raw a
left join #REF_Service_Type_Delivery_Mech b on trim (a.[Service_type]) = trim (b.[Service_Type])
and trim (a.Delivery_Mechanism) = trim (b.[Delivery_Mechanism])
where a.Gender = 'Female'
;


------------------------------------------------------
/*TABLE 3b PROCESSING, FILTERING AND DE-DUPLICATION*/
------------------------------------------------------
--1. Pull out lowest Hierarchy / 'RANK'
drop table if exists #LTS001b_T3b_MinRank
SELECT LA_Code, [ID], Min(Hierarchy) as [RANK]
into #LTS001b_T3b_MinRank
FROM #LTS001b_T3b
GROUP BY LA_Code, [ID]
;

--2. Select only records with a Known Ethnicity if both Known and Unknown exist on same [ID] from cohort 1.
--   (code takes the highest 'Der_Ethnicity_Known' flag where 0 = Unknown and 1 = Known)
if object_id('tempdb..#LTS001b_T3b_Ethnicity_Known','U') is not null drop table #LTS001b_T3b_Ethnicity_Known
SELECT a.LA_Code, b.[ID], b.[RANK], Max(DER_Ethnicity_Known) as [MaxEthnicityKnown]
into #LTS001b_T3b_Ethnicity_Known
FROM #LTS001b_T3b a
left join #LTS001b_T3b_MinRank b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK]
where 
b.[ID] is not NULL
GROUP BY a.LA_Code, b.[ID], b.[RANK]
;


--3. Select the latest Event Start Date of the records from cohort 2.
drop table if exists #LTS001b_T3b_MaxDate
SELECT a.LA_Code, b.[ID], [RANK], [MaxEthnicityKnown], max(Event_Start_Date) as [MaxDate]
into #LTS001b_T3b_MaxDate
FROM #LTS001b_T3b a
left join #LTS001b_T3b_Ethnicity_Known b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_Ethnicity_Known = b.[MaxEthnicityKnown]
where 
b.[ID] is not NULL
group by a.LA_Code, b.[ID], [RANK], [MaxEthnicityKnown]
;



--4. Select the latest Import Date of the records from cohort 3. 
--   Create final COMBINED table
drop table if exists #LTS001b_T3b_COMBINED
SELECT a.La_Code, a.[ID], [RANK], [MaxEthnicityKnown], [MaxDate], max(ImportDate) as [MaxImportDate]
into #LTS001b_T3b_COMBINED
FROM #LTS001b_T3b a
left join #LTS001b_T3b_MaxDate b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_Ethnicity_Known = b.[MaxEthnicityKnown] and a.Event_Start_Date = b.MaxDate
where 
b.[ID] is not NULL
group by a.La_Code, a.[ID], [RANK], [MaxEthnicityKnown], [MaxDate]
;



-- Pull through all the Ethnicity, Service Type and Delivery Mech information for each [ID] in the Combined table
drop table if exists #LTS001b_T3b_Final_Staging
select a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Ethnicity_Description is NULL then 'Invalid/NULL' else c.Ethnicity_Description END as 'Ethnicity'
, a.[ID]
into #LTS001b_T3b_Final_Staging
from #LTS001b_T3b_COMBINED a 
left join #LTS001b_T3b b on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.[RANK] = b.[Hierarchy] and a.MaxEthnicityKnown = b.Der_Ethnicity_Known and a.MaxDate = b.Event_Start_Date and a.MaxImportDate = b.ImportDate
left join #REF_Ethnicity c on b.Ethnicity = c.Ethnicity_Description
group by a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Ethnicity_Description is NULL then 'Invalid/NULL' else c.Ethnicity_Description END
, a.[ID]
;



-- Build a table of Duplicate records - at this stage after the previous de-duplication procedures 1-4 above this will be records
-- that are identical for the purposes of LTS001b apart from having conflicting Ethnicity
drop table if exists #T3b_Ethnicity_Duplicates
select LA_CODE, Service_Type, Delivery_Mechanism, [ID], count([ID]) as [COUNT]
into #T3b_Ethnicity_Duplicates
from #LTS001b_T3b_Final_Staging
group by LA_CODE, Service_Type, Delivery_Mechanism, [ID]
having count([ID]) > 1
;


-- Create Final LTS001b Table 3b
-- Ethnicity is altered as part of the build to over-write any conflicting Ethnicity to 'Unknown' in all instances
drop table if exists #LTS001b_T3b_Final
select distinct 
a.LA_CODE
, CASE When b.[COUNT] is not NULL then 'No data - Undeclared or Not known' else a.Ethnicity End as [Ethnicity]
, a.Service_Type
, a.Delivery_Mechanism
, a.[ID]
into #LTS001b_T3b_Final
from #LTS001b_T3b_Final_Staging a
left join #T3b_Ethnicity_Duplicates b on a.LA_code = b.LA_Code and a.Service_Type = b.Service_Type and a.Delivery_Mechanism = b.Delivery_Mechanism and a.[ID] = b.[ID]
;


-------------------------------
/*PRODUCE COUNTS FOR TABLE 3b*/
-------------------------------
select LA_CODE, Ethnicity, Service_Type, Delivery_Mechanism, count(distinct [ID])
from #LTS001b_T3b_Final
group by LA_CODE, Ethnicity, Service_Type, Delivery_Mechanism
order by LA_CODE
;




--------------------------------------------------------------------
/*TABLE 3c: OTHER CLIENTS LONG TERM SUPPORT AT THE END OF THE YEAR*/
--------------------------------------------------------------------

/*PRODUCE COUNTS FOR TABLE 3c*/
select LA_CODE, count(distinct [ID])
from #LTS001b_Raw
where Gender in ('Other', 'Unknown')
group by LA_CODE
order by LA_CODE
;




-------
/*END*/
-------









-------------------------------------------------------
/*CREATE UNION VERSION OF LTS001b FOR POWER BI REPORT*/
-------------------------------------------------------
--drop table[ASC_Sandbox].[LA_PBI_SALT_LTS001b]
select LA_CODE, Primary_Support_Reason as [Row], Service_Type as [Column1], Delivery_Mechanism as [Column2], count(distinct [ID]) as [Total], '1a' as [Table]
--into [ASC_Sandbox].[LA_PBI_SALT_LTS001b]
from #LTS001b_T1a_Final
group by LA_CODE, Primary_Support_Reason, Service_Type, Delivery_Mechanism
-----
union
-----
select LA_CODE, Primary_Support_Reason as [Row], Service_Type as [Column1], Delivery_Mechanism as [Column2], count(distinct [ID]) as [Total], '1b' as [Table]
from #LTS001b_T1b_Final
group by LA_CODE, Primary_Support_Reason, Service_Type, Delivery_Mechanism
-----
union
-----
select LA_CODE, Has_Unpaid_Carer as [Row], Service_Type as [Column1], Delivery_Mechanism as [Column2], count(distinct [ID]) as [Total], '2' as [Table]
from #LTS001b_T2_Final
group by LA_CODE, Has_Unpaid_Carer, Service_Type, Delivery_Mechanism

