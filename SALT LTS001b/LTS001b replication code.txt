--------------------------------------------------------------
/*CODE TO RE-CREATE LTS001b: ALL TABLES 1A, 1B, 2, 3A AND 3B*/
--------------------------------------------------------------


---------------------------------------------------------------------------------------------------
/*CREATE REFERENCE TABLE #REF_SERVICE_TYPE_DELIVERY_MECH TO CATEGORISE AND RANK ITEMS FOR LTS001b*/
---------------------------------------------------------------------------------------------------
--NOTE: Check periodically to ensure the Defined List in CLD spec has not changed!
drop table if exists #REF_Service_Type_Delivery_Mech	
create table #REF_Service_Type_Delivery_Mech
(Service_Type varchar(200)
,Delivery_Mechanism varchar(200)
,SALT_Category varchar(200)
,SALT_Broad_Category varchar(200)
,Sort_Order int
,Hierarchy int)

insert into #REF_Service_Type_Delivery_Mech
(Service_Type
,Delivery_Mechanism
,SALT_Category
,SALT_Broad_Category
,Sort_Order
,Hierarchy
)
values
('Long Term Support: Nursing Care', '', 'Nursing', 'Nursing', 1, 1)
,('Long Term Support: Residential Care', '', 'Residential', 'Residential', 2, 2)
,('Long Term Support: Community', 'Direct Payment', 'Community: Direct Payment', 'Community', 3, 3)
,('Long Term Support: Community', 'CASSR Managed Personal Budget', 'Community: CASSR Managed Personal Budget', 'Community', 4, 4)
,('Long Term Support: Community', 'CASSR Commissioned Support', 'Community: CASSR Commissioned Support', 'Community', 5, 5)
,('Long Term Support: Community', '', 'Community', 'Community', 6, 6)
,('Long Term Support: Prison', 'CASSR Managed Personal Budget', 'Prison: CASSR Managed Personal Budget', 'Prison', 7, 7)
,('Long Term Support: Prison', 'CASSR Commissioned Support', 'Prison: CASSR Commissioned Support', 'Prison', 8, 8)
,('Long Term Support: Prison', '', 'Prison', 'Prison', 9, 9)
;

------------------------------------------------------------------------------------------------------------------
/*CREATE REFERENCE TABLE #REF_CARER TO ENSURE ONLY VALID 'SUPPORT FROM CARER' FIELDS COME THROUGH INTO FINAL TABLE*/
------------------------------------------------------------------------------------------------------------------
--NOTE: Check periodically to ensure the Defined List in CLD spec has not changed!
drop table if exists #REF_CARER
create table #REF_CARER
(Has_Unpaid_Carer varchar(50))
;


insert into #REF_CARER
(Has_Unpaid_Carer 
)
values
('Yes')
,('No')
,('Invalid')
;


----------------------------------------------------------------------------------------------------
/*CREATE REFERENCE TABLE #REF_ETHNICITY TO GROUP AND ORDER ETHNITICIES FOR LTS001b TABLE 3a AND 3b*/
----------------------------------------------------------------------------------------------------
--NOTE: Check periodically to ensure the Defined List in CLD spec has not changed!
drop table if exists #REF_Ethnicity
create table #REF_Ethnicity
(Ethnicity_Description varchar(200)
,Ethnicity_Group varchar(200)
,Ethnicity_Order int)

insert into #REF_Ethnicity
(Ethnicity_Description
,Ethnicity_Group
,Ethnicity_Order
)
values
('White - English, Welsh, Scottish, Northern Irish or British', 'White', 1)
,('White - Irish', 'White', 2)
,('White - Gypsy or Irish Traveller', 'White', 3)
,('White - Roma', 'White', 4)
,('White - Any other White background', 'White', 5)
,('Mixed or multiple ethnic groups - White and Black Caribbean', 'Mixed / multiple ethnic groups', 6)
,('Mixed or multiple ethnic groups - White and Black African', 'Mixed / multiple ethnic groups', 7)
,('Mixed or multiple ethnic groups - White and Asian', 'Mixed / multiple ethnic groups', 8)
,('Mixed or multiple ethnic groups - Any other Mixed or multiple ethnic background', 'Mixed / multiple ethnic groups', 9)
,('Asian or Asian British - Indian', 'Asian / Asian British', 10)
,('Asian or Asian British - Pakistani', 'Asian / Asian British', 11)
,('Asian or Asian British - Bangladeshi', 'Asian / Asian British', 12)
,('Asian or Asian British - Chinese', 'Asian / Asian British', 13)
,('Asian or Asian British - Any other Asian background', 'Asian / Asian British', 14)
,('Black, Black British, Caribbean or African - African', 'Black / African / Caribbean / Black British', 15)
,('Black, Black British, Caribbean or African - Caribbean', 'Black / African / Caribbean / Black British', 16)
,('Black, Black British, Caribbean or African - Any other Black, Black British or Caribbean background', 'Black / African / Caribbean / Black British', 17)
,('Other ethnic group - Arab', 'Other Ethnic Group', 18)
,('Other ethnic group - Any other ethnic group', 'Other Ethnic Group', 19)
,('No data - Refused', 'No Data', 20)
,('No data - Undeclared or Not known', 'No Data', 21)
;


-------------------------------------------------------------------------------------------
/*CREATE REFERENCE TABLE #REF_PSR TO ENSURE ONLY VALID PSRs COME THROUGH INTO FINAL TABLE*/
-------------------------------------------------------------------------------------------
--NOTE: Check periodically to ensure the Defined List in CLD spec has not changed!
drop table if exists #REF_PSR
create table #REF_PSR
(Primary_Support_Reason varchar(200))
;


insert into #REF_PSR
(Primary_Support_Reason
)
values
('Physical Support: Access & mobility only')
,('Physical Support: Personal care support')
,('Sensory Support: Support for visual impairment')
,('Sensory Support: Support for hearing impairment')
,('Sensory Support: Support for dual impairment')
,('Support with Memory & Cognition')
,('Learning Disability Support')
,('Mental Health Support')
,('Social Support: Substance misuse support')
,('Social Support: Asylum seeker support')
,('Social Support: Support for Social Isolation/Other')
,('Social Support: Support to Carer')
,('Unknown')
;


--------------------------------------------------------------------------
/*CREATE TABLE RETURNING LATEST SUBMISSION WITHIN THE PERIOD OF INTEREST*/
--------------------------------------------------------------------------
/*
This code uses a procedure at the beginning to determine the last file submission
from each LA within the window, on the understanding that this was a Final and complete submission.

This process helps to cut down on duplicates and also ensure that the latest edition of each Event is selected.
Because the CLD submissions append/stack and no old data is deleted, then without running a process such as this below previous 
iterations of old events that have subsequently been updated and/or closed will come through 
e.g an event entered onto the system in 2022 showing as open (no Event End Date) will pass through the date filters later on in the process
despite a more recent LA submission in 2024 showing that the same Event ended/closed in 2023.

Set the date parameters for period of interest at the end of the query as per the annotated instructions
*/

drop table if exists #Latest_Submission
  SELECT DISTINCT
    LA_Name,
    ImportDate
     INTO #Latest_Submission
  FROM (
    SELECT
      *,
      ROW_NUMBER() OVER(PARTITION BY LA_Name, LA_Code ORDER BY ImportDate DESC) row
    FROM (
      SELECT
        LA_Name,
        LA_Code,
        ImportDate,
        MIN(Reporting_Period_Start_Date) Reporting_Period_Start_Date,
        MAX(Reporting_Period_End_Date) Reporting_Period_End_Date
 
	  FROM [DHSC_ASC].[CLD_R1_Raw]
	  	  WHERE LA_Name IS NOT NULL
      GROUP BY
        LA_Name,
        LA_Code,
        ImportDate
    ) a
    WHERE Reporting_Period_Start_Date <= '2023-04-01' --beginning of Q1 of year of interest (always 1st April where snapshot or in-year)
    AND Reporting_Period_End_Date >= '2023-12-31' --end of period of interest (enter snapshot date here if snapshot required)
    AND ImportDate > '2023-12-31' --should be after the Reporting Period End Date (when LAs can submit data from)
    AND CONVERT(date, ImportDate) <= '2024-03-01' --user can specify how late submissions can be accepted from (submission window closes 1month after quarter end)
  ) b
  WHERE row = 1

/*
Worked Example:

For 2023/24 SALT publications
The 'in-year' i.e. whole financial year period 23/24 (e.g. for LTS001a) 
and also the snapshot 31st March 2024 (e.g. for LTS001b)
would be 

    WHERE Reporting_Period_Start_Date <= '2023-04-01'
    AND Reporting_Period_End_Date >= '2024-03-31'
    AND ImportDate > '2024-04-31'
    AND CONVERT(date, ImportDate) <= '2024-05-01'

*/





------------------------------------------------------------------------------
/*FILTER DATA APPROPRIATELY FOR LTS001b INDIVIDUALS AND SELECT SNAPSHOT DATE*/
------------------------------------------------------------------------------
DECLARE
  @SnapshotDate DATE
;


SET @SnapshotDate = '2023-12-31'  -- Set as required
;

drop table if exists #LTS001b_Build
select a.*
, CAST((concat(Der_Birth_Year, '-', Der_Birth_Month, '-', '01')) as DATE) as [Der_DOB] -- Derived using 1st month as an arbitrary date
, FLOOR((DATEDIFF (DAY, (CAST(concat(Der_Birth_Year, '-', Der_Birth_Month, '-', '01') as DATE)), @SnapshotDate))/365.25) as [Der_Age_Snapshot_Date]--Derived Age as per Snapshot
, Case when Primary_Support_Reason = 'Unknown' or Primary_Support_Reason is NULL then 0 else 1 end as [Der_PSR_Known] --used to preference rows as part of de-duplication 
, Case when Has_Unpaid_Carer = 'Unknown' or Has_Unpaid_Carer is NULL then 0 else 1 end as [Der_Carer_Known] --used to preference rows as part of de-duplication 
, Case when Ethnicity = 'No data - Undeclared or Not known' or Ethnicity is NULL then 0 else 1 end as [Der_Ethnicity_Known] --used to preference rows as part of de-duplication 
into #LTS001b_Build
from [DHSC_ASC].[CLD_R1_Raw] a
inner join #Latest_Submission b on a.LA_Name = b.LA_Name and a.ImportDate = b.ImportDate
where [Service_Type] in ('Long Term Support: Nursing Care', 'Long Term Support: Residential Care', 'Long Term Support: Community', 'Long Term Support: Prison')
and Client_Type = 'Service User'
and Event_Start_Date <= @SnapshotDate 
and (Event_End_Date >= @SnapshotDate or Event_End_Date is NULL)
and (Date_of_Death >= @SnapshotDate OR Date_of_Death is NULL)
and (Der_Birth_Month is not NULL and Der_Birth_Year is not NULL) --Only small amount currently but they stop the CAST functions from working. See query below to extract and analyse Unknowns
;


--/*Staging table allowing for analysis of Unknown Age records*/
--drop table if exists #LTS001b_UnknownAges
--select *
--into #LTS001b_UnknownAges
--from [DHSC_ASC].[CLD_R1_Raw]
--where [Service_Type] in ('Long Term Support: Nursing Care', 'Long Term Support: Residential Care', 'Long Term Support: Community', 'Long Term Support: Prison')
--and Client_Type = 'Service User'
--and Event_Start_Date <= @SnapshotDate 
--and (Event_End_Date >= @SnapshotDate or Event_End_Date is NULL)
--and (Date_of_Death >= @SnapshotDate OR Date_of_Death is NULL) 
--and (Der_Birth_Month is NULL or Der_Birth_Year is NULL)
--;



-----------------------------------------
/*CREATE AMALGAMATED NHS/LA IDENTIFIER*/
-----------------------------------------
/*initially, find all individuals with an NHS Number and stage into a temporary table*/                            
drop table if exists #uniquenhs
SELECT DISTINCT Der_Unique_Record_ID, Der_NHS_Number_Traced_Pseudo, Der_LA_Person_Unique_Identifier_Pseudo, 'NHS' as [Source]                                                                                                                                                     
INTO #uniquenhs                                                                                                                                                           
FROM #LTS001b_Build                                                                                                                                               
where Der_NHS_Number_Traced_Pseudo is not NULL                                                                                          
;


/*where the NHS Number is missing, pull through all individuals LA Unique ID
except in those cases where the LA Unique ID is already present and associated with an individual in #uniquenhs*/
drop table if exists #missingnhs
SELECT distinct a.Der_Unique_Record_ID, a.Der_NHS_Number_Traced_Pseudo, a.Der_LA_Person_Unique_Identifier_Pseudo, 'LA' as [Source]                                                                             
INTO #missingnhs                                                                                                                                                           
FROM #LTS001b_Build a                                                                                                                                                
left join #uniquenhs b on a.Der_LA_Person_Unique_Identifier_Pseudo = b.Der_LA_Person_Unique_Identifier_Pseudo                                                                                                          
where a.Der_NHS_Number_Traced_Pseudo is NULL                                                                                              
and b.Der_LA_Person_Unique_Identifier_Pseudo is NULL                                                                                     
;


/*Stack the NHS IDs and the LA IDs from the two temp tables underneath each other in a final table, as an amalgamated 'ID' field*/
drop table if exists #FINAL
select distinct Der_Unique_Record_ID, Der_NHS_Number_Traced_Pseudo as [ID], [Source]                                     
into #FINAL                                                                                                                                                                     
from #uniquenhs                                                                                                                                                           
UNION                                                                                                                                                               
select distinct Der_Unique_Record_ID, Der_LA_Person_Unique_Identifier_Pseudo as [ID], [Source]                        
from #missingnhs
;


/*Add a column to Raw table with the new ID field*/
alter table #LTS001b_Build add [ID] nvarchar (200)
GO
;
update a
set a.[ID] = b.[ID]
from #LTS001b_Build a left join #FINAL b on a.Der_Unique_Record_ID = b.Der_Unique_Record_ID
;

/*delete rows from table where [ID] is NULL
These records can not be assigned to an individual with 100% accuracy and without the risk of double-counting 
as the NHS ID is NULL and the LA ID is already present in the data associated to an NHS Number*/
delete from #LTS001b_Build
where [ID] is NULL
;


/*Create raw table*/
drop table if exists #LTS001b_Raw
select *
into #LTS001b_Raw
from #LTS001b_Build


-------------------------------------------------------------------------------------------------------------------


-----------------------------------------------------------------------------------------
/*OVER-WRITE ANY INVALID OR UNEXPECTED ENTRIES IN THE DELIVERY MECHANISM COLUMN TO ''  */
-----------------------------------------------------------------------------------------
--Delivery Mechanism is currently NOT a mandatory field and so we can not remove records based on inaccuracy in this field
--but leaving invalid/unexpected entries in the field will cause problems with the Reference data join. 
--Solution to this is to blank out ('') any entries that are invalid or where a Delivery Mechanism is not expected (Nursing and Res events)
update a
set a.Delivery_Mechanism = 
(CASE WHEN b.Delivery_Mechanism is not NULL and a.Service_Type in ('Long Term Support: Community', 'Long Term Support: Prison') then a.Delivery_Mechanism 
	  ELSE '' 
	  end)
from #LTS001b_Raw a
left join #REF_Service_Type_Delivery_Mech b on trim (a.[Service_type]) = trim (b.[Service_Type])
and trim (a.Delivery_Mechanism) = trim (b.[Delivery_Mechanism])
;





----------------------------------------------------------------------------
/*TABLE 1a INITIAL BUILD: AGED 18-64 BY PSR AND SETTING/DELIVERY MECHANISM*/
----------------------------------------------------------------------------
--Create T1a table and add relevant fields from Reference data
drop table if exists #LTS001b_T1a
select a.*
,b.[Sort_Order]
,b.[Hierarchy]
into #LTS001b_T1a
from #LTS001b_Raw a
left join #REF_Service_Type_Delivery_Mech b on trim (a.[Service_type]) = trim (b.[Service_Type])
and trim (a.Delivery_Mechanism) = trim (b.[Delivery_Mechanism])
where a.Der_Age_Snapshot_Date between 18 and 64 -- Using the Derived Age field created from Month and Year of Birth
;


------------------------------------------------------
/*TABLE 1a PROCESSING, FILTERING AND DE-DUPLICATION*/
------------------------------------------------------

/* In SALT each Client can only be counted once in each LTS table so de-duplication routines are needed to achieve this.
Code below chooses the record with the lowest 'Rank' in Service_Type/Delivery_Mech Hierarchy as per the REF data
and also tries to deal with instances of multiple PSR on the same ID. This is done by selecting Known PSRs over Unknown and
then from these the PSR on the most recent EVENT_START_DATE*/


--The code has to work in this specific sequence in order to be correct:
--1. For each combination of PSR, Service Type and Delivery Mech - choose the lowest Hierarchy against each ID
-- and then of this cohort
--2. Choose only Known PSR records in instances where both a Known and an Unknown exist for same LTS event (if only Unknowns exist keep these)
-- and then of this cohort
--3. Select the latest Event Start Date


--4. If any duplicate PSRs are still present in rows with identical ID, Hierarchy and Event Start Date, default each instance to Unknown PSR

-- with this final cohort count the distinct IDs by LA, PSR, Service Type and Delivery Mech

--1. Pull out lowest Hierarchy / 'RANK' (a Nursing setting 'trumps' Community setting etc for the same client)
drop table if exists #LTS001b_T1a_MinRank
SELECT LA_Code, [ID], Min(Hierarchy) as [RANK]
into #LTS001b_T1a_MinRank
FROM #LTS001b_T1a
GROUP BY LA_Code, [ID]
;


--2. Select only records with a Known PSR if both Known and Unknown exist on same [ID] from cohort 1.
--   (code takes the highest 'Der_PSR_Known' flag where 0 = Unknown and 1 = Known)
drop table if exists #LTS001b_T1a_PSR_Known
SELECT a.LA_Code, b.[ID], b.[RANK], Max(DER_PSR_Known) as [MaxPSRKnown]
into #LTS001b_T1a_PSR_Known
FROM #LTS001b_T1a a
left join #LTS001b_T1a_MinRank b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK]
where 
b.[ID] is not NULL
GROUP BY a.LA_Code, b.[ID], b.[RANK]
;


--3. Select the latest Event Start Date of the records from cohort 2.
drop table if exists #LTS001b_T1a_COMBINED
SELECT a.LA_Code, b.[ID], [RANK], [MaxPSRKnown], max(Event_Start_Date) as [MaxDate]
into #LTS001b_T1a_COMBINED
FROM #LTS001b_T1a a
left join #LTS001b_T1a_PSR_Known b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_PSR_Known = b.[MaxPSRKnown]
where 
b.[ID] is not NULL
group by a.LA_Code, b.[ID], [RANK], [MaxPSRKnown]
;
 


 -- Pull through all the PSR, Service Type and Delivery Mech information for each [ID] in the Combined table
-- as part of this, now over-write any Invalid (as per the spec) or NULL PSRs as 'Invalid/Null'
drop table if exists #LTS001b_T1a_Final_Staging
select a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Primary_Support_Reason is NULL then 'Invalid/NULL' else c.Primary_Support_Reason END as 'Primary_Support_Reason'
, a.[ID]
into #LTS001b_T1a_Final_Staging
from #LTS001b_T1a_COMBINED a 
left join #LTS001b_T1a b on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.[RANK] = b.[Hierarchy] and a.MaxPSRKnown = b.Der_PSR_Known and a.MaxDate = b.Event_Start_Date
left join #REF_PSR c on b.Primary_Support_Reason = c.Primary_Support_Reason
group by a.LA_CODE, b.Service_Type, b.Delivery_Mechanism 
, CASE WHEN c.Primary_Support_Reason is NULL then 'Invalid/NULL' else c.Primary_Support_Reason END
, a.[ID]
;



-- Build a table of Duplicate records - at this stage after the previous de-duplication procedures 1-3 above this will be records
-- that are identical for the purposes of LTS001b apart from having conflicting PSRs
drop table if exists #T1a_PSR_Duplicates
select LA_CODE, Service_Type, Delivery_Mechanism, [ID], count([ID]) as [COUNT]
into #T1a_PSR_Duplicates
from #LTS001b_T1a_Final_Staging
group by LA_CODE, Service_Type, Delivery_Mechanism, [ID]
having count([ID]) > 1
;



-- Create Final LTS001b Table 1a
-- PSR is altered as part of the build to over-write any conflicting PSRs to 'Unknown' in all instances
drop table if exists #LTS001b_T1a_Final
select distinct 
a.LA_CODE
, CASE When b.[COUNT] is not NULL then 'Unknown' else a.Primary_Support_Reason End as [Primary_Support_Reason]
, a.Service_Type
, a.Delivery_Mechanism
, a.[ID]
into #LTS001b_T1a_Final
from #LTS001b_T1a_Final_Staging a
left join #T1a_PSR_Duplicates b on a.LA_code = b.LA_Code and a.Service_Type = b.Service_Type and a.Delivery_Mechanism = b.Delivery_Mechanism and a.[ID] = b.[ID]
;



-------------------------------
/*PRODUCE COUNTS FOR TABLE 1a*/
-------------------------------
select LA_CODE, Primary_Support_Reason, Service_Type, Delivery_Mechanism, count(distinct [ID])
from #LTS001b_T1a_Final
group by LA_CODE, Primary_Support_Reason, Service_Type, Delivery_Mechanism
order by LA_CODE
;

select LA_CODE, count(distinct[ID])
from #LTS001b_T1a_Final
group by LA_CODE





--------------------------------------------------------------------------
/*TABLE 1b INITIAL BUILD: AGED 65+ BY PSR AND SETTING/DELIVERY MECHANISM*/
--------------------------------------------------------------------------
--Create T1b table and add relevant fields from Reference data
drop table if exists #LTS001b_T1b
select a.*
,b.[Sort_Order]
,b.[Hierarchy]
into #LTS001b_T1b
from #LTS001b_Raw a
left join #REF_Service_Type_Delivery_Mech b on trim (a.[Service_type]) = trim (b.[Service_Type])
and trim (a.Delivery_Mechanism) = trim (b.[Delivery_Mechanism])
where a.Der_Age_Snapshot_Date > 64 -- Using the Derived Age field created from Month and Year of Birth
;


------------------------------------------------------
/*TABLE 1b PROCESSING, FILTERING AND DE-DUPLICATION*/
------------------------------------------------------
--SEE NOTES as as Table 1a above for full rationale


--1. Pull out lowest Hierarchy / 'RANK'
drop table if exists #LTS001b_T1b_MinRank
SELECT LA_Code, [ID], Min(Hierarchy) as [RANK]
into #LTS001b_T1b_MinRank
FROM #LTS001b_T1b
GROUP BY LA_Code, [ID]
;


--2. Select only records with a Known PSR if both Known and Unknown exist on same [ID] from cohort 1.
--   (code takes the highest 'Der_PSR_Known' flag where 0 = Unknown and 1 = Known)
drop table if exists #LTS001b_T1b_PSR_Known
SELECT a.LA_Code, b.[ID], b.[RANK], Max(DER_PSR_Known) as [MaxPSRKnown]
into #LTS001b_T1b_PSR_Known
FROM #LTS001b_T1b a
left join #LTS001b_T1b_MinRank b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK]
where 
b.[ID] is not NULL
GROUP BY a.LA_Code, b.[ID], b.[RANK]
;



--3. Select the latest Event Start Date of the records from cohort 2.
drop table if exists #LTS001b_T1b_COMBINED
SELECT a.LA_Code, b.[ID], [RANK], [MaxPSRKnown], max(Event_Start_Date) as [MaxDate]
into #LTS001b_T1b_COMBINED
FROM #LTS001b_T1b a
left join #LTS001b_T1b_PSR_Known b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_PSR_Known = b.[MaxPSRKnown]
where 
b.[ID] is not NULL
group by a.LA_Code, b.[ID], [RANK], [MaxPSRKnown]
;



-- Pull through all the PSR, Service Type and Delivery Mech information for each [ID] in the Combined table
-- as part of this, now over-write any Invalid (as per the spec) or NULL PSRs as 'Invalid/Null'
-- as leaving these populated causes duplicates to pull through into the final table
drop table if exists #LTS001b_T1b_Final_Staging
select a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Primary_Support_Reason is NULL then 'Invalid/NULL' else c.Primary_Support_Reason END as 'Primary_Support_Reason'
, a.[ID]
into #LTS001b_T1b_Final_Staging
from #LTS001b_T1b_COMBINED a 
left join #LTS001b_T1b b on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.[RANK] = b.[Hierarchy] and a.MaxPSRKnown = b.Der_PSR_Known and a.MaxDate = b.Event_Start_Date
left join #REF_PSR c on b.Primary_Support_Reason = c.Primary_Support_Reason
group by a.LA_CODE, b.Service_Type, b.Delivery_Mechanism 
, CASE WHEN c.Primary_Support_Reason is NULL then 'Invalid/NULL' else c.Primary_Support_Reason END
, a.[ID]
;




-- Build a table of Duplicate records - at this stage after the previous de-duplication procedures 1-3 above this will be records
-- that are identical for the purposes of LTS001b apart from having conflicting PSRs
drop table if exists #T1b_PSR_Duplicates
select LA_CODE, Service_Type, Delivery_Mechanism, [ID], count([ID]) as [COUNT]
into #T1b_PSR_Duplicates
from #LTS001b_T1b_Final_Staging
group by LA_CODE, Service_Type, Delivery_Mechanism, [ID]
having count([ID]) > 1
;


-- Create Final LTS001b Table 1b
-- PSR is altered as part of the build to over-write any conflicting PSRs to 'Unknown' in all instances
drop table if exists #LTS001b_T1b_Final
select distinct 
a.LA_CODE
, CASE When b.[COUNT] is not NULL then 'Unknown' else a.Primary_Support_Reason End as [Primary_Support_Reason]
, a.Service_Type
, a.Delivery_Mechanism
, a.[ID]
into #LTS001b_T1b_Final
from #LTS001b_T1b_Final_Staging a
left join #T1b_PSR_Duplicates b on a.LA_code = b.LA_Code and a.Service_Type = b.Service_Type and a.Delivery_Mechanism = b.Delivery_Mechanism and a.[ID] = b.[ID]
;


-------------------------------
/*PRODUCE COUNTS FOR TABLE 1b*/
-------------------------------
select LA_CODE, Primary_Support_Reason, Service_Type, Delivery_Mechanism, count(distinct [ID])
from #LTS001b_T1b_Final
group by LA_CODE, Primary_Support_Reason, Service_Type, Delivery_Mechanism
order by LA_CODE

select LA_CODE, count(distinct [ID])
from #LTS001b_T1b_Final
group by LA_CODE
order by LA_CODE


SELECT COUNT(DISTINCT [ID])
FROM #LTS001b_T1A_Final

SELECT COUNT(DISTINCT [ID])
FROM #LTS001b_T1b_Final






------------------------------------------------------------------------------------------
/*TABLE 2 INITIAL BUILD: ALL AGES BY 'SUPPORT FROM CARER' AND SETTING/DELIVERY MECHANISM*/
------------------------------------------------------------------------------------------
--Create T2 table and add relevant fields from Reference data
drop table if exists #LTS001b_T2
select a.*
,b.[Sort_Order]
,b.[Hierarchy]
into #LTS001b_T2
from #LTS001b_Raw a
left join #REF_Service_Type_Delivery_Mech b on trim (a.[Service_type]) = trim (b.[Service_Type])
and trim (a.Delivery_Mechanism) = trim (b.[Delivery_Mechanism])
;


----------------------------------------------------
/*TABLE 2 PROCESSING, FILTERING AND DE-DUPLICATION*/
----------------------------------------------------
--This needs to choose the record with the lowest Service_Type/Delivery_Mech Hierarchy as per the REF data
--But also deal with potential of conflicting Support From Carer (Yes/No) on the same Pseudo ID

--1. Pull out lowest Hierarchy / 'RANK'
drop table if exists #LTS001b_T2_MinRank
SELECT LA_Code, [ID], Min(Hierarchy) as [RANK]
into #LTS001b_T2_MinRank
FROM #LTS001b_T2
GROUP BY LA_Code, [ID]
;

--2. Select only records with a Known 'Has Unpaid Carer' field if both Known and Unknown exist on same [ID] from cohort 1.
--   (code takes the highest 'Der_Carer_Known' flag where 0 = Unknown and 1 = Known)
drop table if exists #LTS001b_T2_Carer_Known
SELECT a.LA_Code, b.[ID], b.[RANK], Max(Der_Carer_Known) as [MaxCarerKnown]
into #LTS001b_T2_Carer_Known
FROM #LTS001b_T2 a
left join #LTS001b_T2_MinRank b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK]
where 
b.[ID] is not NULL
GROUP BY a.LA_Code, b.[ID], b.[RANK]
;
 

--3. Select the latest Event Start Date of the records from cohort 2.
drop table if exists #LTS001b_T2_COMBINED
SELECT a.LA_Code, b.[ID], [RANK], [MaxCarerKnown], max(Event_Start_Date) as [MaxDate]
into #LTS001b_T2_COMBINED
FROM #LTS001b_T2 a
left join #LTS001b_T2_Carer_Known b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_Carer_Known = b.[MaxCarerKnown]
where 
b.[ID] is not NULL
group by a.LA_Code, b.[ID], [RANK], [MaxCarerKnown]
;
 


-- Pull through all the Has_Unpaid_Carer, Service Type and Delivery Mech information for each [ID] in the Combined table
drop table if exists #LTS001b_T2_Final_Staging
select a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Has_Unpaid_Carer is NULL then 'Invalid/NULL' else c.Has_Unpaid_Carer END as 'Has_Unpaid_Carer'
, a.[ID]
into #LTS001b_T2_Final_Staging
from #LTS001b_T2_COMBINED a 
left join #LTS001b_T2 b on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.[RANK] = b.[Hierarchy] and a.MaxCarerKnown = b.Der_Carer_Known and a.MaxDate = b.Event_Start_Date
left join #REF_CARER c on b.Has_Unpaid_Carer = c.Has_Unpaid_Carer
group by a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Has_Unpaid_Carer is NULL then 'Invalid/NULL' else c.Has_Unpaid_Carer END 
, a.[ID]
;




-- Build a table of Duplicate records - at this stage after the previous de-duplication procedures 1-3 above this will be records
-- that are identical for the purposes of LTS001b apart from having conflicting 'Has Unpaid Carer' field
drop table if exists #T2_Carer_Duplicates
select LA_CODE, Service_Type, Delivery_Mechanism, [ID], count([ID]) as [COUNT]
into #T2_Carer_Duplicates
from #LTS001b_T2_Final_Staging
group by LA_CODE, Service_Type, Delivery_Mechanism, [ID]
having count([ID]) > 1
;



-- Create Final LTS001b Table 2
-- Has_Unpaid_Carer is altered as part of the build to over-write any conflicting Carer info to 'Unknown' in all instances
drop table if exists #LTS001b_T2_Final
select distinct 
a.LA_CODE
, CASE When b.[COUNT] is not NULL then 'Unknown' else a.Has_Unpaid_Carer End as [Has_Unpaid_Carer]
, a.Service_Type
, a.Delivery_Mechanism
, a.[ID]
into #LTS001b_T2_Final
from #LTS001b_T2_Final_Staging a
left join #T2_Carer_Duplicates b on a.LA_code = b.LA_Code and a.Service_Type = b.Service_Type and a.Delivery_Mechanism = b.Delivery_Mechanism and a.[ID] = b.[ID]
;



-------------------------------
/*PRODUCE COUNTS FOR TABLE 2*/
-------------------------------
select LA_CODE, Has_Unpaid_Carer, Service_Type, Delivery_Mechanism, count(distinct [ID])
from #LTS001b_T2_Final
group by LA_CODE, Has_Unpaid_Carer, Service_Type, Delivery_Mechanism
order by LA_CODE
;





-----------------------------------------------------------------------------
/*TABLE 3a INITIAL BUILD: MALES BY ETHNICITY AND SETTING/DELIVERY MECHANISM*/
-----------------------------------------------------------------------------
--Create T3a table and add relevant fields from Reference data
drop table if exists #LTS001b_T3a
select a.*
,b.[Sort_Order]
,b.[Hierarchy]
into #LTS001b_T3a
from #LTS001b_Raw a
left join #REF_Service_Type_Delivery_Mech b on trim (a.[Service_type]) = trim (b.[Service_Type])
and trim (a.Delivery_Mechanism) = trim (b.[Delivery_Mechanism])
where a.Gender = 'Male'
;


------------------------------------------------------
/*TABLE 3a PROCESSING, FILTERING AND DE-DUPLICATION*/
------------------------------------------------------
--1. Pull out lowest Hierarchy / 'RANK'
drop table if exists #LTS001b_T3a_MinRank
SELECT LA_Code, [ID], Min(Hierarchy) as [RANK]
into #LTS001b_T3a_MinRank
FROM #LTS001b_T3a
GROUP BY LA_Code, [ID]
;

--2. Select only records with a Known Ethnicity if both Known and Unknown exist on same [ID] from cohort 1.
--   (code takes the highest 'Der_Ethnicity_Known' flag where 0 = Unknown and 1 = Known)
drop table if exists #LTS001b_T3a_Ethnicity_Known
SELECT a.LA_Code, b.[ID], b.[RANK], Max(DER_Ethnicity_Known) as [MaxEthnicityKnown]
into #LTS001b_T3a_Ethnicity_Known
FROM #LTS001b_T3a a
left join #LTS001b_T3a_MinRank b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK]
where 
b.[ID] is not NULL
GROUP BY a.LA_Code, b.[ID], b.[RANK]
;


--3. Select the latest Event Start Date of the records from cohort 2.
drop table if exists #LTS001b_T3a_COMBINED
SELECT a.LA_Code, b.[ID], [RANK], [MaxEthnicityKnown], max(Event_Start_Date) as [MaxDate]
into #LTS001b_T3a_COMBINED
FROM #LTS001b_T3a a
left join #LTS001b_T3a_Ethnicity_Known b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_Ethnicity_Known = b.[MaxEthnicityKnown]
where 
b.[ID] is not NULL
group by a.LA_Code, b.[ID], [RANK], [MaxEthnicityKnown]
;



-- Pull through all the Ethnicity, Service Type and Delivery Mech information for each [ID] in the Combined table
drop table if exists #LTS001b_T3a_Final_Staging
select a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Ethnicity_Description is NULL then 'Invalid/NULL' else c.Ethnicity_Description END as 'Ethnicity'
, a.[ID]
into #LTS001b_T3a_Final_Staging
from #LTS001b_T3a_COMBINED a 
left join #LTS001b_T3a b on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.[RANK] = b.[Hierarchy] and a.MaxEthnicityKnown = b.Der_Ethnicity_Known and a.MaxDate = b.Event_Start_Date
left join #REF_Ethnicity c on b.Ethnicity = c.Ethnicity_Description
group by a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Ethnicity_Description is NULL then 'Invalid/NULL' else c.Ethnicity_Description END
, a.[ID]
;


-- Build a table of Duplicate records - at this stage after the previous de-duplication procedures 1-4 above this will be records
-- that are identical for the purposes of LTS001b apart from having conflicting Ethnicity
drop table if exists #T3a_Ethnicity_Duplicates
select LA_CODE, Service_Type, Delivery_Mechanism, [ID], count([ID]) as [COUNT]
into #T3a_Ethnicity_Duplicates
from #LTS001b_T3a_Final_Staging
group by LA_CODE, Service_Type, Delivery_Mechanism, [ID]
having count([ID]) > 1
;


-- Create Final LTS001b Table 3a
-- Ethnicity is altered as part of the build to over-write any conflicting Ethnicity to 'Unknown' in all instances
drop table if exists #LTS001b_T3a_Final
select distinct 
a.LA_CODE
, CASE When b.[COUNT] is not NULL then 'No data - Undeclared or Not known' else a.Ethnicity End as [Ethnicity]
, a.Service_Type
, a.Delivery_Mechanism
, a.[ID]
into #LTS001b_T3a_Final
from #LTS001b_T3a_Final_Staging a
left join #T3a_Ethnicity_Duplicates b on a.LA_code = b.LA_Code and a.Service_Type = b.Service_Type and a.Delivery_Mechanism = b.Delivery_Mechanism and a.[ID] = b.[ID]
;


-------------------------------
/*PRODUCE COUNTS FOR TABLE 3a*/
-------------------------------
select LA_CODE, Ethnicity, Service_Type, Delivery_Mechanism, count(distinct [ID])
from #LTS001b_T3a_Final
group by LA_CODE, Ethnicity, Service_Type, Delivery_Mechanism
order by LA_CODE
;





-----------------------------------------------------------------
/*TABLE 3b: FEMALES BY ETHNICITY AND SETTING/DELIVERY MECHANISM*/
-----------------------------------------------------------------

--Create T3b table and add relevant fields from Reference data
drop table if exists #LTS001b_T3b
select a.*
,b.[Sort_Order]
,b.[Hierarchy]
into #LTS001b_T3b
from #LTS001b_Raw a
left join #REF_Service_Type_Delivery_Mech b on trim (a.[Service_type]) = trim (b.[Service_Type])
and trim (a.Delivery_Mechanism) = trim (b.[Delivery_Mechanism])
where a.Gender = 'Female'
;


------------------------------------------------------
/*TABLE 3b PROCESSING, FILTERING AND DE-DUPLICATION*/
------------------------------------------------------
--1. Pull out lowest Hierarchy / 'RANK'
drop table if exists #LTS001b_T3b_MinRank
SELECT LA_Code, [ID], Min(Hierarchy) as [RANK]
into #LTS001b_T3b_MinRank
FROM #LTS001b_T3b
GROUP BY LA_Code, [ID]
;

--2. Select only records with a Known Ethnicity if both Known and Unknown exist on same [ID] from cohort 1.
--   (code takes the highest 'Der_Ethnicity_Known' flag where 0 = Unknown and 1 = Known)
drop table if exists #LTS001b_T3b_Ethnicity_Known
SELECT a.LA_Code, b.[ID], b.[RANK], Max(DER_Ethnicity_Known) as [MaxEthnicityKnown]
into #LTS001b_T3b_Ethnicity_Known
FROM #LTS001b_T3b a
left join #LTS001b_T3b_MinRank b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK]
where 
b.[ID] is not NULL
GROUP BY a.LA_Code, b.[ID], b.[RANK]
;


--3. Select the latest Event Start Date of the records from cohort 2.
drop table if exists #LTS001b_T3b_COMBINED
SELECT a.LA_Code, b.[ID], [RANK], [MaxEthnicityKnown], max(Event_Start_Date) as [MaxDate]
into #LTS001b_T3b_COMBINED
FROM #LTS001b_T3b a
left join #LTS001b_T3b_Ethnicity_Known b on a.LA_CODE = b.LA_CODE and a.[ID] = b.[ID] and a.Hierarchy = b.[RANK] and a.Der_Ethnicity_Known = b.[MaxEthnicityKnown]
where 
b.[ID] is not NULL
group by a.LA_Code, b.[ID], [RANK], [MaxEthnicityKnown]
;



-- Pull through all the Ethnicity, Service Type and Delivery Mech information for each [ID] in the Combined table
drop table if exists #LTS001b_T3b_Final_Staging
select a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Ethnicity_Description is NULL then 'Invalid/NULL' else c.Ethnicity_Description END as 'Ethnicity'
, a.[ID]
into #LTS001b_T3b_Final_Staging
from #LTS001b_T3b_COMBINED a 
left join #LTS001b_T3b b on a.LA_Code = b.LA_CODE and a.[ID] = b.[ID] and a.[RANK] = b.[Hierarchy] and a.MaxEthnicityKnown = b.Der_Ethnicity_Known and a.MaxDate = b.Event_Start_Date
left join #REF_Ethnicity c on b.Ethnicity = c.Ethnicity_Description
group by a.LA_CODE, b.Service_Type, b.Delivery_Mechanism
, CASE WHEN c.Ethnicity_Description is NULL then 'Invalid/NULL' else c.Ethnicity_Description END
, a.[ID]
;



-- Build a table of Duplicate records - at this stage after the previous de-duplication procedures 1-3 above this will be records
-- that are identical for the purposes of LTS001b apart from having conflicting Ethnicity
drop table if exists #T3b_Ethnicity_Duplicates
select LA_CODE, Service_Type, Delivery_Mechanism, [ID], count([ID]) as [COUNT]
into #T3b_Ethnicity_Duplicates
from #LTS001b_T3b_Final_Staging
group by LA_CODE, Service_Type, Delivery_Mechanism, [ID]
having count([ID]) > 1
;


-- Create Final LTS001b Table 3b
-- Ethnicity is altered as part of the build to over-write any conflicting Ethnicity to 'Unknown' in all instances
drop table if exists #LTS001b_T3b_Final
select distinct 
a.LA_CODE
, CASE When b.[COUNT] is not NULL then 'No data - Undeclared or Not known' else a.Ethnicity End as [Ethnicity]
, a.Service_Type
, a.Delivery_Mechanism
, a.[ID]
into #LTS001b_T3b_Final
from #LTS001b_T3b_Final_Staging a
left join #T3b_Ethnicity_Duplicates b on a.LA_code = b.LA_Code and a.Service_Type = b.Service_Type and a.Delivery_Mechanism = b.Delivery_Mechanism and a.[ID] = b.[ID]
;


-------------------------------
/*PRODUCE COUNTS FOR TABLE 3b*/
-------------------------------
select LA_CODE, Ethnicity, Service_Type, Delivery_Mechanism, count(distinct [ID])
from #LTS001b_T3b_Final
group by LA_CODE, Ethnicity, Service_Type, Delivery_Mechanism
order by LA_CODE
;




--------------------------------------------------------------------
/*TABLE 3c: OTHER CLIENTS LONG TERM SUPPORT AT THE END OF THE YEAR*/
--------------------------------------------------------------------

/*PRODUCE COUNTS FOR TABLE 3c*/
select LA_CODE, count(distinct [ID])
from #LTS001b_Raw
where Gender in ('Other', 'Unknown')
group by LA_CODE
order by LA_CODE
;




-------
/*END*/
-------
